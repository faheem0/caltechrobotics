//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Microsoft.Ccr.Core;
using Microsoft.Dss.Core;
using Microsoft.Dss.Core.Attributes;
using Microsoft.Dss.ServiceModel.Dssp;
using Microsoft.Dss.Core.DsspHttp;
using Microsoft.Dss.ServiceModel.DsspServiceBase;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Xml;
using W3C.Soap;
using robomagellan = RoboMagellan;
using gps = RoboMagellan.GenericGPS.Proxy;
using motor = RoboMagellan.MotorControl.Proxy;
using submgr = Microsoft.Dss.Services.SubscriptionManager;
using compass = RoboMagellan.GenericCompass.Proxy;

namespace RoboMagellan
{
    
    public class ControlDataPort : PortSet<MainControlUpdateState, Exception>{ }
    
    /// <summary>
    /// Implementation class for MainControl
    /// </summary>
    [DisplayName("MainControl")]
    [Description("The MainControl Service")]
    [Contract(Contract.Identifier)]
    public class MainControlService : DsspServiceBase
    {
        private static double DISTANCE_THRESHOLD = 1;

        private static double ANGLE_THRESHOLD = 10;

        private ControlDataPort CPort = new ControlDataPort();


        [Partner("Gps", Contract = gps.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UseExistingOrCreate)]
        private gps.GenericGPSOperations _gpsPort = new gps.GenericGPSOperations();
        private gps.GenericGPSOperations _gpsNotify = new gps.GenericGPSOperations();

        [Partner("Compass", Contract = compass.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UseExistingOrCreate)]
        private compass.GenericCompassOperations _compassPort = new compass.GenericCompassOperations();
        private compass.GenericCompassOperations _compassNotify = new compass.GenericCompassOperations();

        [Partner("Motor", Contract = motor.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UseExistingOrCreate)]
        private motor.GenericMotorOperations _motorPort = new motor.GenericMotorOperations();

        [Partner("SubMgr", Contract = submgr.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.CreateAlways)]
        submgr.SubscriptionManagerPort _subMgrPort = new submgr.SubscriptionManagerPort();

        /// <summary>
        /// _state
        /// </summary>
        private MainControlState _state = new MainControlState();

        private MainControlUpdateState _update = new MainControlUpdateState();
        
        /// <summary>
        /// _main Port
        /// </summary>
        [ServicePort("/maincontrol", AllowMultipleInstances=false)]
        private MainControlOperations _mainPort = new MainControlOperations();
        
        /// <summary>
        /// Default Service Constructor
        /// </summary>
        public MainControlService(DsspServiceCreationPort creationPort) : 
                base(creationPort)
        {
            _state._state = MainControlStates.STATE_STOPPED;
        }

        private void EnqueueWaypoints()
        {
            /*
            _state._destination = new gps.UTMData();
            _state._destination.East = 396499.33;
            _state._destination.North = 3777944.93;

            _state._destinations.Enqueue(_state._destination);
            /*
            _state._destination = new gps.UTMData();
            _state._destination.East = 396499.33;
            _state._destination.North = 3777944.93;

            _state._destinations.Enqueue(_state._destination);
            _state._destination = new gps.UTMData();
            _state._destination.East = 396497.06;
            _state._destination.North = 3777944.35;

            _state._destinations.Enqueue(_state._destination);

            _state._destination = new gps.UTMData();
            _state._destination.East = 396496.79;
            _state._destination.North = 3777942.28;
            */
        }
        
        /// <summary>
        /// Service Start
        /// MODIFIES STATE!
        /// </summary>
        protected override void Start()
        {
			base.Start();
			// Add service specific initialization here.
            Console.WriteLine("MainControl initializing");
            DirectoryInsert();
            this.EnqueueWaypoints();

            Activate<ITask>(
                Arbiter.Interleave(
                    new TeardownReceiverGroup(),
                    new ExclusiveReceiverGroup(
                       Arbiter.Receive<gps.UTMNotification>(true, _gpsNotify, NotifyUTMHandler),
                       Arbiter.Receive<compass.CompassNotification>(true, _compassNotify, NotifyCompassHandler)),
                   new ConcurrentReceiverGroup()));

            //_state._destination = _state._destinations.Dequeue();
//            Activate<ITask>(
//                Arbiter.Receive<gps.UTMNotification>(true, _gpsNotify, NotifyUTMHandler)
//                );

            /*Interleave mainInterleave = ActivateDsspOperationHandlers();
            mainInterleave.CombineWith(new Interleave(new ExclusiveReceiverGroup(
                Arbiter.Receive<MainControlUpdateState>(true, CPort, DataReceivedHandler)),
                new ConcurrentReceiverGroup()));
            */
            PostUpdate();
            _compassPort.Subscribe(_compassNotify);
            Console.WriteLine("Subscribed to compass");
            _gpsPort.Subscribe(_gpsNotify);
            Console.WriteLine("Subscribed to GPS, standing by");
        }

        public void NotifyCompassHandler(compass.CompassNotification c)
        {
            if (_state._state != MainControlStates.STATE_DRIVING) return;

            // if the compass bearings arent in the same reference as the gps generated bearings this wont work, should ask EEs about this

            double absoluteBearing = GetAbsoluteBearing(_state._location, _state._destination);
            double actualBearing = c.Body.angle;
            Console.WriteLine("Actual Bearing: " + actualBearing);
            Console.WriteLine("Absolute Bearing: " + absoluteBearing);
            if (Math.Abs(absoluteBearing - actualBearing) > ANGLE_THRESHOLD)
            {
                Console.WriteLine("Stopping because actual bearing (" + actualBearing + ") outside angle threshold (intended bearing is " + actualBearing + ")");
                _state._state = MainControlStates.STATE_STOPPING;
                PostUpdate();
                motor.Stop stop = new motor.Stop();
                Arbiter.Activate(this.TaskQueue, Arbiter.Receive<DefaultSubmitResponseType>(false, stop.ResponsePort,
                    delegate(DefaultSubmitResponseType a)
                    {
                        _state._state = MainControlStates.STATE_STOPPED;
                        PostUpdate();
                        Console.WriteLine("Received stop!");
                    }));

                _motorPort.Post(stop);
            }
        }

        // UPDATES STATE!
        // fix concurrency!
        public void NotifyUTMHandler(gps.UTMNotification n)
        {
            Console.WriteLine("Received GPS notification, current state: " + _state._state);
            _state._location = n.Body;
            PostUpdate();
            if (_state._destination.East == 0 && _state._destination.North == 0)
            {
                _state._state = MainControlStates.STATE_STANDBY;
                PostUpdate();
            }
            switch (_state._state)
            {
                case MainControlStates.STATE_STANDBY :
                    if (_state._destinations.Count > 0)
                    {
                        _state._destination = _state._destinations.Dequeue();
                        _state._state = MainControlStates.STATE_STOPPED;
                        PostUpdate();
                    }
                    break;
                case MainControlStates.STATE_STOPPING :
                    return;
                    break;
                case MainControlStates.STATE_STOPPED:
                    if (_state._destination.East == 0.0) break;
                    if (GetDistanceSquared(_state._destination, n.Body) < DISTANCE_THRESHOLD)
                    {
                        return;
                    }
                    else
                    {
                        double absoluteBearing = GetAbsoluteBearing(n.Body, _state._destination);
                        Console.WriteLine("Beginning turn");
                        motor.TurnData td = new motor.TurnData();
                        td.heading = (int)absoluteBearing;
                        motor.Turn t = new motor.Turn(td);


                        _state._state = MainControlStates.STATE_TURNING;
                        PostUpdate();

                        Arbiter.Activate(this.TaskQueue, Arbiter.Receive<DefaultSubmitResponseType>(false, t.ResponsePort,
                            delegate(DefaultSubmitResponseType s)
                            {
                                Console.WriteLine("Received turn complete!");
                                _state._state = MainControlStates.STATE_DRIVING;
                                PostUpdate();
                                motor.MotorSpeed ms = new motor.MotorSpeed();
                                ms.Left = 20;
                                ms.Right = 20;
                                motor.SetSpeed setspeed = new motor.SetSpeed(ms);
                                _motorPort.Post(setspeed);
                            }));
//                            delegate(Exception ex) { _state._state = MainControlStates.STATE_ERROR; }));


                        _motorPort.Post(t);
                    }
                    break;
                case MainControlStates.STATE_TURNING:
                    return;
                    break;
                case MainControlStates.STATE_DRIVING:
                    if (GetDistanceSquared(_state._destination, n.Body) < DISTANCE_THRESHOLD)
                    {
                        motor.Stop stop = new motor.Stop();

                        Console.WriteLine("Stopping!");
                        _state._state = MainControlStates.STATE_STOPPING;
                        PostUpdate();
                        Arbiter.Activate(this.TaskQueue, Arbiter.Receive<DefaultSubmitResponseType>(false, stop.ResponsePort,
                            delegate(DefaultSubmitResponseType a) { 
                                _state._state = MainControlStates.STATE_STOPPED;
                                PostUpdate();
                                Console.WriteLine("Received stop!");
                                if (_state._destinations.Count > 0)
                                {
                                    _state._destination = _state._destinations.Dequeue();
                                    PostUpdate();
                                }
                                else
                                {
                                    gps.UTMData empty = new gps.UTMData();
                                    empty.East = 0.0;
                                    empty.North = 0.0;
                                    _state._destination = empty;
                                    PostUpdate();
                                }
                            }));
//                            delegate(Exception ex) { _state._state = STATE_ERROR; }));

                        _motorPort.Post(stop);

                    }
                    else
                    {
                        return;
                    }
                    break;
                case MainControlStates.STATE_ERROR:
                    return;
                    break;
            }
        }

        private void PostUpdate()
        {
            _update._state = _state._state;
            _update._location = _state._location;
            _update._destination = _state._destination;
            // double check that this is safe...
            _update._destinations = _state._destinations.ToArray();
            CPort.Post(_update);
            SendNotification(_subMgrPort, new StateNotification(_update)); 
        }

        public double GetDistance(gps.UTMData a, gps.UTMData b)
        {
            return Math.Sqrt(GetDistanceSquared(a, b));
        }

        public double GetDistanceSquared(gps.UTMData a, gps.UTMData b)
        {
            double de = b.East - a.East;
            double dn = b.North - a.North;
            return de * de + dn * dn;
        }
        public double GetAbsoluteBearing(gps.UTMData loc, gps.UTMData dest)
        {
            double dx = dest.East - loc.East;
            double dy = dest.North - loc.North;

            return 180 * (Math.Atan(dy / dx) / Math.PI);
        }

        /// <summary>
        /// Get Handler
        /// </summary>
        /// <param name="get"></param>
        /// <returns></returns>
        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public virtual IEnumerator<ITask> GetHandler(Get get)
        {
            get.ResponsePort.Post(_state);
            yield break;
        }

        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public virtual IEnumerator<ITask> HttpGetHandler(HttpGet httpGet)
        {
            httpGet.ResponsePort.Post(new HttpResponseType(_update));
            yield break;
        }

        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public IEnumerator<ITask> HttpPostHandler(HttpPost httpPost)
        {
            yield break;
        }

        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public virtual IEnumerator<ITask> SubscribeHandler(Subscribe subscribe)
        {
            SubscribeRequestType request = subscribe.Body;
            Console.WriteLine("Control received subscribe request");
            yield return Arbiter.Choice(
                SubscribeHelper(_subMgrPort, request, subscribe.ResponsePort),
                delegate(SuccessResult success)
                {
                    Console.WriteLine("Subscription confirmed");
                    SendNotification<StateNotification>(_subMgrPort, request.Subscriber, _update);
                },
                delegate(Exception e)
                {
                    LogError(null, "Subscribe failed", e);
                }
            );

            yield break;
        }

        private void DataReceivedHandler(MainControlUpdateState d)
        {
            //Console.WriteLine("Received Control data");
            //_state.Coords = d;

            SendNotification(_subMgrPort, new StateNotification(d));
        }

        [ServiceHandler(ServiceHandlerBehavior.Exclusive)]
        public IEnumerator<ITask> EnqueueHandler(Enqueue s)
        {
            gps.UTMData data = s.Body;
            _state._destinations.Enqueue(data);
            PostUpdate();
            yield break;
        }
    }
}
