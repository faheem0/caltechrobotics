//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Microsoft.Ccr.Core;
using Microsoft.Dss.Core;
using Microsoft.Dss.Core.Attributes;
using Microsoft.Dss.ServiceModel.Dssp;
using Microsoft.Dss.Core.DsspHttp;
using Microsoft.Dss.ServiceModel.DsspServiceBase;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Xml;
using System.Drawing;
using System.Drawing.Imaging;
using System.Runtime.InteropServices;
using System.IO;
using W3C.Soap;
using conedetect = RoboMagellan.ConeDetect;
using webcam = Microsoft.Robotics.Services.WebCam.Proxy;
using multiwebcam = Microsoft.Robotics.Services.MultiDeviceWebCam.Proxy;
using physics = Microsoft.Robotics.PhysicalModel.Proxy;
using submgr = Microsoft.Dss.Services.SubscriptionManager;

namespace RoboMagellan.ConeDetect
{
    
    
    /// <summary>
    /// Implementation class for ConeDetect
    /// </summary>
    [DisplayName("ConeDetect")]
    [Description("The ConeDetect Service")]
    [Contract(Contract.Identifier)]
    public class ConeDetectService : DsspServiceBase
    {

        private static float DIMENSION_X = 174;
        private static float DIMENSION_Y = 144;

        private static physics.Vector2 SIZE;
        private static float TOLERANCE_H = 20.0f;
        private static float TOLERANCE_S = 0.38f;
        private static float TOLERANCE_B = 0.42f;
        private static int DETECT_THRESHOLD = (int)(DIMENSION_X * DIMENSION_Y) / 17;
        private static int FPS = 10;
        private static Color ConeColor = Color.FromArgb(239,58,31);//Color.OrangeRed;//Color.FromArgb(239,58,31);
        private static Color MaskColor = Color.Black;
        private static float SMALL_DENSITY_THRESHOLD = 0.5f;
        private static int SMALL_DENSITY_BOX = 15;
        
        /// <summary>
        /// _state
        /// </summary>
        private ConeDetectState _state = new ConeDetectState();
        
        /// <summary>
        /// _main Port
        /// </summary>
        [ServicePort("/conedetect", AllowMultipleInstances=false)]
        private ConeDetectOperations _mainPort = new ConeDetectOperations();

        
        [Partner("SubMgr", Contract = submgr.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.CreateAlways)]
        submgr.SubscriptionManagerPort _subMgrPort = new submgr.SubscriptionManagerPort();

        /*[Partner("MultiWebcam", Contract = multiwebcam.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UseExistingOrCreate)]
        multiwebcam.WebCamServiceOperations _multiWebcam = new multiwebcam.WebCamServiceOperations();*/

        [Partner("Webcam", Contract = webcam.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UseExistingOrCreate)]
        webcam.WebCamOperations _camData = new webcam.WebCamOperations();
        webcam.WebCamOperations _camNotify = new webcam.WebCamOperations();

        /// <summary>
        /// Default Service Constructor
        /// </summary>
        public ConeDetectService(DsspServiceCreationPort creationPort) : 
                base(creationPort)
        {
        }
        
        /// <summary>
        /// Service Start
        /// </summary>
        protected override void Start()
        {
            if (_state == null)
            {
                _state = new ConeDetectState();

                _state.WebCamPollingIntervalInMs = 100;

                _state.TrackingObjectColor = new ColorVector(0.51, 0.23, 0.26, 0.99);
                _state.ColorAreaThreshold = 200;
                _state.SkinAreaThreshold = 250;
                _state.HeadAreaThreshold = 250;

                base.SaveState(_state);
            }

	        base.Start();
            DirectoryInsert();
            Console.WriteLine("Webcam Starting");
            //DirectoryInsert();
            /*webcam.WebCamState f = new Microsoft.Robotics.Services.WebCam.WebCamState();
            f.ImageSize.X = DIMENSION_X;
            f.ImageSize.X = DIMENSION_Y;
            mdwebcam.
            webcam.*/
            SIZE.X = DIMENSION_X;
            SIZE.Y = DIMENSION_Y;

            Activate(Arbiter.ReceiveWithIterator(false, TimeoutPort(2000), GetFrame));

            _camData.Subscribe(_camNotify);
            Console.WriteLine("Webcam started");
	        // Add service specific initialization here.
        }
        public IEnumerator<ITask> GetFrame(DateTime timeout)
        {
            
            Fault fault = null;
            webcam.QueryFrameRequest request = new webcam.QueryFrameRequest();
            webcam.QueryFrameResponse response = new webcam.QueryFrameResponse();
            
            request.Format = ImageFormat.Bmp.Guid;
            request.Size = SIZE;

            
            yield return Arbiter.Choice(
                _camData.QueryFrame(request),
                delegate(webcam.QueryFrameResponse success)
                    {
                        response = success;
                    },
                delegate(Fault f)
                    {
                        fault = f;
                    }
            );

            if (fault != null)
            {
                yield break;
            }
            if (response != null && response.Frame != null)
            {
                try
                {
                    Bitmap frame = null;
                    MemoryStream stream = new MemoryStream(response.Frame, false);
                    frame = new Bitmap(stream);

                    CamData data = processImage(frame);

                    SendNotification<ConeNotification>(_subMgrPort, data);
                }
                catch (Exception e)
                {

                }
            }

            Activate(Arbiter.ReceiveWithIterator(false, TimeoutPort(1000/FPS), GetFrame));
        }

        private CamData processImage(Bitmap frame)
        {
            CamData data = new CamData();
            data.OrgImage = frame;
            data.Image = new Bitmap(frame.Width,frame.Height);
            float mass = 0.0f;
            float center_x = 0.0f;
            float center_y = 0.0f;
            int count = 0;

            Color c;
            for (int i = 0; i < frame.Width; i++)
            {
                for (int j = 0; j < frame.Height; j++)
                {
                    c = frame.GetPixel(i, j);
                    //tw.Write(String.Format("{0:0.00}", bm.GetPixel(i, j).GetHue()) + " ");
                    if (isBetween(c.GetHue(), ConeColor.GetHue() - TOLERANCE_H, ConeColor.GetHue() + TOLERANCE_H))
                    {
                        if (isBetween(c.GetSaturation(), ConeColor.GetSaturation() - TOLERANCE_S, ConeColor.GetSaturation() + TOLERANCE_S))
                        {
                            if (isBetween(c.GetBrightness(), ConeColor.GetBrightness() - TOLERANCE_B, ConeColor.GetBrightness() + TOLERANCE_B))
                            {
                                data.Image.SetPixel(i, j, Color.White);
                                mass += 1;
                                center_x += i;
                                center_y += j;
                                count++;
                            }
                            else
                            {
                                data.Image.SetPixel(i, j, Color.Black);
                            }
                        }
                        else
                        {
                            data.Image.SetPixel(i, j, Color.Black);
                        }
                    }
                    else
                    {
                        data.Image.SetPixel(i, j, Color.Black);
                    }
                }
            }
            data.X = (int)(center_x / mass);
            data.Y = (int)(center_y / mass);
            if (count > DETECT_THRESHOLD)
            {
                Density_Check d = checkDensity(data, SMALL_DENSITY_BOX, SMALL_DENSITY_THRESHOLD);
                if (d.pass)
                {
                    data.Detected = true;
                    data.Box = d.r;
                }
                else data.Detected = false;
            }
            else data.Detected = false;
            //Console.WriteLine(data.Box.ToString());
            return data;
        }
        private Density_Check checkDensity(CamData data, int size, float threshold)
        {
            int X_min = data.X - size;
            int X_max = data.X + size;
            int Y_min = data.Y - size;
            int Y_max = data.Y + size;

            if (X_min < 0) X_min = 0;
            if (X_max > DIMENSION_X) X_max = (int)DIMENSION_X;
            if (Y_min < 0) Y_min = 0;
            if (Y_max > DIMENSION_Y) Y_max = (int)DIMENSION_Y;
            Density_Check d = new Density_Check();
            d.r = new Rectangle(X_min, Y_min, X_max - X_min, Y_max - Y_min);

            float count = 0.0f;
            float area = 4 * size * size;
            Color c;
            for (int i = X_min; i <= X_max; i++)
            {
                for (int j = Y_min; j <= Y_max; j++)
                {
                    c = data.Image.GetPixel(i,j);
                    if (c.R == Color.White.R && c.G == Color.White.G && c.B == Color.White.B)
                    {
                        //Console.WriteLine("(" + i + "," + j + ")");
                        count++;
                    }
                }
            }
            //Console.WriteLine(count / area);

            if (count / area >= threshold)
            {
                d.pass = true;
                return d;
            }
            else
            {
                d.pass = false;
                return d;
            }
        }
        private bool isBetween(float v, float l, float u)
        {
            return v > l && v < u;
        }
        
        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public virtual IEnumerator<ITask> SubscribeHandler(Subscribe subscribe)
        {
            SubscribeRequestType request = subscribe.Body;
            Console.WriteLine("Cone Detection received subscribe request");
            yield return Arbiter.Choice(
                SubscribeHelper(_subMgrPort, request, subscribe.ResponsePort),
                delegate(SuccessResult success)
                {
                    Console.WriteLine("Cone Detection Subscription confirmed");
                    SendNotification<ConeNotification>(_subMgrPort, request.Subscriber, new CamData());
                },
                delegate(Exception e)
                {
                    LogError(null, "Cone Detection Subscribe failed", e);
                }
            );

            yield break;
        }
        /// <summary>
        /// Get Handler
        /// </summary>
        /// <param name="get"></param>
        /// <returns></returns>
        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public virtual IEnumerator<ITask> GetHandler(Get get)
        {
            get.ResponsePort.Post(_state);
            yield break;
        }

        [ServiceHandler(ServiceHandlerBehavior.Exclusive)]
        public IEnumerator<ITask> CalibrateHandler(Calibrate s)
        {
            ConeColor = s.Body.Color;
            yield break;
        }
    }
}
