//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Microsoft.Ccr.Core;
using Microsoft.Dss.Core;
using Microsoft.Dss.Core.Attributes;
using Microsoft.Dss.ServiceModel.Dssp;
using Microsoft.Dss.Core.DsspHttp;
using Microsoft.Dss.ServiceModel.DsspServiceBase;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Xml;
using System.Drawing;
using System.Drawing.Imaging;
using System.Runtime.InteropServices;
using System.IO;
using W3C.Soap;
using conedetect = RoboMagellan.ConeDetect;
using webcam = Microsoft.Robotics.Services.WebCam.Proxy;
using multiwebcam = Microsoft.Robotics.Services.MultiDeviceWebCam.Proxy;
using physics = Microsoft.Robotics.PhysicalModel.Proxy;
using submgr = Microsoft.Dss.Services.SubscriptionManager;

namespace RoboMagellan.ConeDetect
{
    
    
    /// <summary>
    /// Implementation class for ConeDetect
    /// </summary>
    [DisplayName("ConeDetect")]
    [Description("The ConeDetect Service")]
    [Contract(Contract.Identifier)]
    public class ConeDetectService : DsspServiceBase
    {

        private static float DIMENSION_X = 600;
        private static float DIMENSION_Y = 480;

        private static physics.Vector2 SIZE;
        private static int TOLERANCE = 70;
        private static int FPS = 10;
        private static Color ConeColor = Color.FromArgb(239,58,31);
        private static Color MaskColor = Color.Black;
        
        /// <summary>
        /// _state
        /// </summary>
        private ConeDetectState _state = new ConeDetectState();
        
        /// <summary>
        /// _main Port
        /// </summary>
        [ServicePort("/conedetect", AllowMultipleInstances=false)]
        private ConeDetectOperations _mainPort = new ConeDetectOperations();

        
        [Partner("SubMgr", Contract = submgr.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.CreateAlways)]
        submgr.SubscriptionManagerPort _subMgrPort = new submgr.SubscriptionManagerPort();

        /*[Partner("MultiWebcam", Contract = multiwebcam.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UseExistingOrCreate)]
        multiwebcam.WebCamServiceOperations _multiWebcam = new multiwebcam.WebCamServiceOperations();*/

        [Partner("Webcam", Contract = webcam.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UseExistingOrCreate)]
        webcam.WebCamOperations _camData = new webcam.WebCamOperations();
        webcam.WebCamOperations _camNotify = new webcam.WebCamOperations();

        /// <summary>
        /// Default Service Constructor
        /// </summary>
        public ConeDetectService(DsspServiceCreationPort creationPort) : 
                base(creationPort)
        {
        }
        
        /// <summary>
        /// Service Start
        /// </summary>
        protected override void Start()
        {
            if (_state == null)
            {
                _state = new ConeDetectState();

                _state.WebCamPollingIntervalInMs = 100;

                _state.TrackingObjectColor = new ColorVector(0.51, 0.23, 0.26, 0.99);
                _state.ColorAreaThreshold = 200;
                _state.SkinAreaThreshold = 250;
                _state.HeadAreaThreshold = 250;

                base.SaveState(_state);
            }

			base.Start();
            DirectoryInsert();
            Console.WriteLine("Webcam Starting");
            //DirectoryInsert();
            /*webcam.WebCamState f = new Microsoft.Robotics.Services.WebCam.WebCamState();
            f.ImageSize.X = DIMENSION_X;
            f.ImageSize.X = DIMENSION_Y;
            mdwebcam.
            webcam.*/
            SIZE.X = DIMENSION_X;
            SIZE.Y = DIMENSION_Y;

            Activate(Arbiter.ReceiveWithIterator(false, TimeoutPort(3000), GetFrame));

            _camData.Subscribe(_camNotify);
            Console.WriteLine("Webcam started");
			// Add service specific initialization here.
        }
        public IEnumerator<ITask> GetFrame(DateTime timeout)
        {
            
            Fault fault = null;
            webcam.QueryFrameRequest request = new webcam.QueryFrameRequest();
            webcam.QueryFrameResponse response = new webcam.QueryFrameResponse();
            
            request.Format = ImageFormat.Bmp.Guid;
            request.Size = SIZE;

            
            yield return Arbiter.Choice(
                _camData.QueryFrame(request),
                delegate(webcam.QueryFrameResponse success)
                    {
                        response = success;
                    },
                delegate(Fault f)
                    {
                        fault = f;
                    }
            );

            if (fault != null)
            {
                yield break;
            }
            if (response != null && response.Frame != null)
            {
                try
                {
                    Bitmap frame = null;
                    MemoryStream stream = new MemoryStream(response.Frame, false);
                    frame = new Bitmap(stream);

                    CamData data = processImage(frame);

                    SendNotification<ConeNotification>(_subMgrPort, data);
                }
                catch (Exception e)
                {

                }
            }

            Activate(Arbiter.ReceiveWithIterator(false, TimeoutPort(FPS), GetFrame));
        }

        private CamData processImage(Bitmap frame)
        {
            CamData data = new CamData();
           
            Color c;
           for (int i = 0; i < frame.Width; i++)
            {
                for (int j = 0; j < frame.Height; j++)
                {
                    c = frame.GetPixel(i, j);

                    /*if (!(isBetween(c.G, ConeColor.G - TOLERANCE, ConeColor.G + TOLERANCE)
                        && isBetween(c.R, ConeColor.R - TOLERANCE, ConeColor.R + TOLERANCE)
                        && isBetween(c.B, ConeColor.B - TOLERANCE, ConeColor.B + TOLERANCE)
                        ))
                    {
                        
                        frame.SetPixel(i, j, MaskColor);
                    }
                    else
                    {
                        
                    }*/
                    
                }
                
            }
            data.Image = frame;
            return data;
        }
        private bool isBetween(int v, int l, int u)
        {
            return v > l && v < u;
        }
        
        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public virtual IEnumerator<ITask> SubscribeHandler(Subscribe subscribe)
        {
            SubscribeRequestType request = subscribe.Body;
            Console.WriteLine("Cone Detection received subscribe request");
            yield return Arbiter.Choice(
                SubscribeHelper(_subMgrPort, request, subscribe.ResponsePort),
                delegate(SuccessResult success)
                {
                    Console.WriteLine("Cone Detection Subscription confirmed");
                    SendNotification<ConeNotification>(_subMgrPort, request.Subscriber, new CamData());
                },
                delegate(Exception e)
                {
                    LogError(null, "Cone Detection Subscribe failed", e);
                }
            );

            yield break;
        }
        /// <summary>
        /// Get Handler
        /// </summary>
        /// <param name="get"></param>
        /// <returns></returns>
        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public virtual IEnumerator<ITask> GetHandler(Get get)
        {
            get.ResponsePort.Post(_state);
            yield break;
        }
    }
}
