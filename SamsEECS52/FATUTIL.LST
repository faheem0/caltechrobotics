iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE   1


DOS 5.0 (038-N) iC-86 COMPILER V4.0, COMPILATION OF MODULE FATUTIL
OBJECT MODULE PLACED IN FATUTIL.OBJ
COMPILER INVOKED BY: C:\ASMSTU~1\IC86.EXE FATUTIL.C DEBUG EXTEND MOD186 SMALL OPTIMIZE(0) NOALIGN ROM

 line level  incl 

    1             /****************************************************************************/
    2             /*                                                                          */
    3             /*                                 FATUTIL                                  */
    4             /*              Utility Functions for Reading a FAT16 Hard Drive            */
    5             /*                           MP3 Jukebox Project                            */
    6             /*                                EE/CS 52                                  */
    7             /*                                                                          */
    8             /****************************************************************************/
    9             
   10             /*
   11                This file contains utility functions for reading a FAT16 hard drive.  The
   12                current directory information and the path are kept locally in this file.
   13                The functions included are:
   14                   cur_isDir              - is the current file a directory
   15                   cur_isParentDir        - is the current file the parent directory (..)
   16                   get_cur_file_attr      - get the attributes of the current file
   17                   get_cur_file_name      - get the name of the current file
   18                   get_cur_file_sector    - get the starting sector of the current file
   19                   get_cur_file_size      - get the size in bytes of the current file
   20                   get_cur_file_time      - get the time of the current file
   21                   get_first_dir_entry    - get the first file in the current directory
   22                   get_next_dir_entry     - get next file in the current directory
   23                   get_previous_dir_entry - get previous file in the current directory
   24                   init_FAT_system        - initialize the FAT file system
   25             
   26                The local functions included are:
   27                   init_dir_stack         - initialize the directory name stack
   28                   new_directory          - entering a new directory, update the stack
   29                   get_dir_tos_name       - get name on the top of the stack
   30                   get_dir_tos_sector     - get starting sector of directory at tos
   31             
   32                The locally global variable definitions included are:
   33                   cur_dir                - current file entry in dir_sector[]
   34                   cur_sector             - starting sector of current directory entry
   35                   dir_offset             - current sector offset in the current directory
   36                   dir_sector             - array of directory entries in a sector
   37                   dirname                - name of current directory
   38                   dirnames               - names of directories on stack as a char []
   39                   dirnamestack           - stack of name positions in dirnames[]
   40                   dirsectorstack         - stack of starting directory sector numbers
   41                   dirstack_ptr           - the stack pointer into directory info stacks
   42                   filename               - filename of current directory entry
   43                   first_file_sector      - sector of the first file on the hard drive
   44                   partition_start        - starting sector of the first partition
   45                   sectors_per_cluster    - number of sectors per cluster
   46                   start_sector           - starting sector of current directory
   47             
   48             
   49                Revision History
   50                   6/5/03   Glen George       Initial revision.
   51                   6/10/03  Glen George       Updated get_cur_file_time() to use macros
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE   2


   52                                              to extract the hours/minutes/seconds from a
   53                                              word in the directory entry, rather than bit
   54                                              fields which aren't convenient in Intel C.
   55                   6/10/03  Glen George       Changed code to not display volume label
   56                                              entries and instead use them as the name of
   57                                              the root directory.
   58                   6/10/03  Glen George       Updated comments.
   59                   6/11/03  Glen George       Changed code to use new packed int time and
   60                                              date structure for directory entries.
   61                   6/11/03  Glen George       Fixed minor problem with unterminated
   62                                              comment.
   63                   4/29/06  Glen George       Removed inclusion of string.h, that's handled
   64                                              by mp3defs.h now.
   65                   4/29/06  Glen George       Changed all calls to get_blocks to use words
   66                                              (short int) instead of bytes (char).
   67                   4/29/06  Glen George       Switched to using unions and macros for
   68                                              accessing hard drive data for portability.
   69                   5/3/06   Glen George       Updated to use the modified macros in vfat.h
   70                                              for portability.
   71                   5/3/06   Glen George       Updated to use the modified macros in vfat.h
   72                                              for portability.
   73                   5/3/06   Glen George       Updated to use the modified macros in vfat.h
   74                                              for portability.
   75                   5/3/06   Glen George       Updated to use the modified macros in vfat.h
   76                                              for portability.
   77                   6/5/08   Glen George       Modified to also read the partition table to
   78                                              get the start of the first partition.  Mainly
   79                                              adds the shared variable partition_start
   80                              which is added to all hard drive sector
   81                              numbers.
   82             */
   83             
   84             
   85             
   86             
   87             /* library include files */
   88               /* none */
   89             
   90             /* local include files */
   91             #include  "mp3defs.h"
   92             #include  "interfac.h"
   93             #include  "vfat.h"
   94             #include  "fatutil.h"
   95             
   96             
   97             
   98             
   99             /* local definitions */
  100               /* none */
  101             
  102             
  103             
  104             
  105             /* local function declarations */
  106             void                init_dir_stack(void);       /* initialize stack of directory names */
  107             void                new_directory(void);        /* entering a new directory, update stack */
  108             const char         *get_dir_tos_name(void);     /* get name of directory at top of stack */
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE   3


  109             unsigned long int   get_dir_tos_sector(void);   /* get starting sector of directory at top of stack */
  110             
  111             
  112             
  113             
  114             /* locally global variables */
  115             
  116             /* local variables shared by directory functions */
  117             static  union  VFAT_dir_entry  dir_sector[ENTRIES_PER_SECTOR];  /* directory entries in a sector */
  118             static  int                    cur_dir;             /* current entry in dir_sector[] */
  119             
  120             static  unsigned long int      partition_start;     /* starting sector number of the first partition *
                -/
  121             
  122             static  long int               sectors_per_cluster; /* number of sectors per cluster */
  123             static  unsigned long int      first_file_sector;   /* sector of the first file on the hard drive */
  124             
  125             static  unsigned long int      start_sector;        /* starting sector of directory */
  126             static  int                    dir_offset;          /* sector offset in directory */
  127             
  128             static  unsigned long int      cur_sector;          /* starting sector of current entry */
  129             
  130             static  char  dirname[MAX_LFN_LEN];                 /* name of current directory */
  131             static  char  filename[MAX_LFN_LEN];                /* filename of current entry */
  132             
  133             
  134             
  135             
  136             /*
  137                init_FAT_system(unsigned long int, long int)
  138             
  139                Description:      This function initializes FAT file system.
  140                    
  141                Operation:        The function reads the partition table and boot record to
  142                              set up the directory parameters: the starting sector
  143                                  number for files on the drive, and the number of sectors
  144                                  per cluster.  It also initializes the directory stack and
  145                                  the directory name and filename.
  146             
  147                Arguments:        None.
  148                Return Value:     (long int) - starting sector of the root directory, zero
  149                                  if there is an error.
  150             
  151                Inputs:           None.
  152                Outputs:          None.
  153             
  154                Error Handling:   If there is an error reading the drive or interpretting
  155                                  the data, zero (0) is returned.
  156             
  157                Algorithms:       None.
  158                Data Structures:  None.
  159             
  160                Shared Variables: first_file_sector   - set to the computed sector number.
  161                              partition_start     - starting sector number of the
  162                                            partition.
  163                                  sectors_per_cluster - set to the read sectors per
  164                                                        cluster.
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE   4


  165             
  166                Author:           Glen George
  167                Last Modified:    June 5, 2008
  168             
  169             */
  170             
  171             long int  init_FAT_system()
  172             {
  173     1           /* variables */
  174     1           union  first_sector    s;               /* the boot sector */
  175     1       
  176     1           long int               root_dir_start;  /* start of the root directory */
  177     1       
  178     1           char                   error;           /* drive reading error flag */
  179     1       
  180     1       
  181     1       
  182     1           /* read the first sector from the harddrive to get the partition table */
  183     1           error = (get_blocks(0, 1, (unsigned short int far *) &s) != 1);
  184     1       
  185     1           /* compute and store the starting sector of the partition */
  186     1           partition_start = (unsigned long int) s.words[PARTITION_START_LO] +
  187     1                             (((unsigned long int) s.words[PARTITION_START_HI]) << 16);
  188     1       
  189     1       
  190     1           /* now read the first sector of the partition from the harddrive */
  191     1           /* retrieves the BIOS Parameter Block (assuming no errors) */
  192     1           error = error || (get_blocks(partition_start, 1, (unsigned short int far *) &s) != 1);
  193     1       
  194     1       
  195     1           /* compute the start of the root directory (in sectors) */
  196     1           root_dir_start = RESERVED_SECTORS(s) + (NUMFATS(s) * FAT_SECTORS(s));
  197     1       
  198     1       
  199     1           /* set the drive variables */
  200     1           if (!error)  {
  201     2               /* if no error set the parameters from the boot sector value */
  202     2               first_file_sector = root_dir_start + (ROOT_ENTRIES(s) / ENTRIES_PER_SECTOR);
  203     2               sectors_per_cluster = ALLOC_SECTORS(s);
  204     2           }
  205     1           else  {
  206     2               /* there was an error - set the parameters to default values */
  207     2               first_file_sector = 1;
  208     2               sectors_per_cluster = 64;
  209     2           }
  210     1       
  211     1       
  212     1           /* initialize the directory name stack */
  213     1           init_dir_stack();
  214     1       
  215     1       
  216     1           /* initialize the directory and file names */
  217     1           dirname[0] = '\0';
  218     1           filename[0] = '\0';
  219     1       
  220     1       
  221     1           /* and return the start of the root directory or an error indicator */
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE   5


  222     1           if (error)
  223     1               /* error - return 0 */
  224     1               return  0;
  225     1           else
  226     1               /* no error - return the start of the root directory */
  227     1               return  root_dir_start;
  228     1       
  229     1       }
  230             
  231             
  232             
  233             
  234             /*
  235                get_cur_file_name
  236             
  237                Description:      This function returns a pointer to the name of the
  238                                  current directory entry (a filename).
  239             
  240                Arguments:        None.
  241                Return Value:     (const char *) - pointer to the name of the current
  242                                  directory entry.  If the entry has a long filename that
  243                                  filename is returned, otherwise the 8.3 filename is
  244                                  returned.  If there is no current directory, due to an
  245                                  error, and empty string is returned.
  246             
  247                Inputs:           None.
  248                Outputs:          None.
  249             
  250                Error Handling:   None.
  251             
  252                Algorithms:       None.
  253                Data Structures:  None.
  254             
  255                Shared Variables: filename - accessed by this function.
  256             
  257                Author:           Glen George
  258                Last Modified:    June 1, 2003
  259             
  260             */
  261             
  262             const char  *get_cur_file_name()
  263             {
  264     1           /* variables */
  265     1             /* none */
  266     1       
  267     1       
  268     1       
  269     1           /* just return a pointer to the current filename */
  270     1           return  filename;
  271     1       
  272     1       }
  273             
  274             
  275             
  276             
  277             /*
  278                get_cur_file_attr
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE   6


  279             
  280                Description:      This function returns the attribute byte of the current
  281                                  directory entry.
  282             
  283                Arguments:        None.
  284                Return Value:     (unsigned char) - attribute byte of the current directory
  285                                  entry (a file).  If there is no current directory entry
  286                                  due to an error, zero is returned.
  287             
  288                Inputs:           None.
  289                Outputs:          None.
  290             
  291                Error Handling:   None.
  292             
  293                Algorithms:       None.
  294                Data Structures:  None.
  295             
  296                Shared Variables: dir_sector - accessed to determine attribute.
  297                                  cur_dir    - accessed to determine current attribute.
  298             
  299                Author:           Glen George
  300                Last Modified:    April 29, 2006
  301             
  302             */
  303             
  304             unsigned char  get_cur_file_attr()
  305             {
  306     1           /* variables */
  307     1             /* none */
  308     1       
  309     1       
  310     1       
  311     1           /* just return the attribute of the current directory entry */
  312     1           return  ATTR(dir_sector[cur_dir]);
  313     1       
  314     1       }
  315             
  316             
  317             
  318             
  319             /*
  320                cur_isDir
  321             
  322                Description:      This function returns whether or not the current file
  323                                  entry is a subdirectory.
  324             
  325                Arguments:        None.
  326                Return Value:     (char) - TRUE if the current entry is a subdirectory,
  327                                  FALSE if it is not.
  328             
  329                Inputs:           None.
  330                Outputs:          None.
  331             
  332                Error Handling:   None.
  333             
  334                Algorithms:       None.
  335                Data Structures:  None.
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE   7


  336             
  337                Shared Variables: dir_sector - accessed to determine directory status.
  338                                  cur_dir    - accessed to determine directory status.
  339             
  340                Author:           Glen George
  341                Last Modified:    June 27, 2002
  342             
  343             */
  344             
  345             char  cur_isDir()
  346             {
  347     1           /* variables */
  348     1             /* none */
  349     1       
  350     1       
  351     1       
  352     1           /* just return whether or not current entry is a directory */
  353     1           return  ((get_cur_file_attr() & ATTRIB_DIR) != 0);
  354     1       
  355     1       }
  356             
  357             
  358             
  359             
  360             /*
  361                cur_isParentDir
  362             
  363                Description:      This function returns whether or not the current file
  364                                  entry is the parent directory.
  365             
  366                Arguments:        None.
  367                Return Value:     (char) - TRUE if the current entry is the parent
  368                                  directory (".."), FALSE if it is not.
  369             
  370                Inputs:           None.
  371                Outputs:          None.
  372             
  373                Error Handling:   None.
  374             
  375                Algorithms:       None.
  376                Data Structures:  None.
  377             
  378                Shared Variables: dir_sector - accessed to determine directory status.
  379                                  cur_dir    - accessed to determine directory status.
  380             
  381                Author:           Glen George
  382                Last Modified:    April 29, 2006
  383             
  384             */
  385             
  386             char  cur_isParentDir()
  387             {
  388     1           /* variables */
  389     1             /* none */
  390     1       
  391     1       
  392     1       
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE   8


  393     1           /* just return whether or not current entry is the parent directory */
  394     1           /* it's the parent if the name starts with '.' */
  395     1           return  (cur_isDir() && (FILENAME(dir_sector[cur_dir], 0) == '.'));
  396     1       
  397     1       }
  398             
  399             
  400             
  401             
  402             /*
  403                get_cur_file_time
  404             
  405                Description:      This function returns the time (in seconds) of the
  406                                  current directory entry (a file).
  407             
  408                Arguments:        None.
  409                Return Value:     (unsigned int) - the time stamp for the current
  410                                  directory entry in seconds.  If there is no current
  411                                  directory entry due to an error, zero is returned.
  412             
  413                Inputs:           None.
  414                Outputs:          None.
  415             
  416                Error Handling:   None.
  417             
  418                Algorithms:       None.
  419                Data Structures:  None.
  420             
  421                Shared Variables: cur_sector - accessed by this function.
  422             
  423                Author:           Glen George
  424                Last Modified:    April 29, 2006
  425             
  426             */
  427             
  428             unsigned int  get_cur_file_time()
  429             {
  430     1           /* variables */
  431     1           unsigned int  t;            /* the file time (in seconds) */
  432     1       
  433     1       
  434     1       
  435     1           /* first get the seconds (kept in units of 2 seconds) */
  436     1           t = 2 * DIR_SECONDS(FTIME(dir_sector[cur_dir]));
  437     1           /* then add in the minutes and hours */
  438     1           t += 60 * DIR_MINUTES(FTIME(dir_sector[cur_dir]));
  439     1           t += 60 * 60 * DIR_HOURS(FTIME(dir_sector[cur_dir]));
  440     1       
  441     1       
  442     1           /* and return the resulting time in seconds */
  443     1           return  t;
  444     1       
  445     1       }
  446             
  447             
  448             
  449             
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE   9


  450             /*
  451                get_cur_file_size
  452             
  453                Description:      This function returns the size of the current directory
  454                                  entry (a file) in bytes.
  455             
  456                Arguments:        None.
  457                Return Value:     (unsigned long int) - size (in bytes) of the current
  458                                  directory entry.  If there is no current directory entry
  459                                  due to an error, zero is returned.
  460             
  461                Inputs:           None.
  462                Outputs:          None.
  463             
  464                Error Handling:   None.
  465             
  466                Algorithms:       None.
  467                Data Structures:  None.
  468             
  469                Shared Variables: cur_sector - accessed by this function.
  470             
  471                Author:           Glen George
  472                Last Modified:    April 29, 2006
  473             
  474             */
  475             
  476             long int  get_cur_file_size()
  477             {
  478     1           /* variables */
  479     1             /* none */
  480     1       
  481     1       
  482     1       
  483     1           /* return the length in bytes of the current directory entry */
  484     1           return  FSIZE(dir_sector[cur_dir]);
  485     1       
  486     1       }
  487             
  488             
  489             
  490             
  491             /*
  492                get_cur_file_sector
  493             
  494                Description:      This function returns the starting sector of the current
  495                                  directory entry (a file).
  496             
  497                Arguments:        None.
  498                Return Value:     (unsigned long int) - starting sector of the current
  499                                  directory entry.  If there is no current directory entry
  500                                  due to an error, zero is returned.
  501             
  502                Inputs:           None.
  503                Outputs:          None.
  504             
  505                Error Handling:   None.
  506             
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE  10


  507                Algorithms:       None.
  508                Data Structures:  None.
  509             
  510                Shared Variables: cur_sector - accessed by this function.
  511             
  512                Author:           Glen George
  513                Last Modified:    June 1, 2003
  514             
  515             */
  516             
  517             unsigned long int  get_cur_file_sector()
  518             {
  519     1           /* variables */
  520     1             /* none */
  521     1       
  522     1       
  523     1       
  524     1           /* return the starting sector of the current directory entry */
  525     1           return  cur_sector;
  526     1       
  527     1       }
  528             
  529             
  530             
  531             
  532             /*
  533                get_first_dir_entry
  534             
  535                Description:      This function gets the first valid directory entry in
  536                                  the directory whose starting sector number is passed.
  537                                  The long filename of this directory entry is also read
  538                                  and the filename variable is set to this long filename
  539                                  if it exists or the 8.3 filename if there is no long
  540                                  filename.  Finally the starting sector number of this
  541                                  entry is also saved.  If there is an error reading the
  542                                  directory entry the filename is set to the empty string,
  543                                  the starting sector number is set to 0, the directory
  544                                  information is properly initialized, and TRUE is
  545                                  returned.  The function get_next_dir_entry is used to
  546                                  actually get the first directory entry.
  547             
  548                Arguments:        first_sector (unsigned long int) - starting sector number
  549                                                                     of the directory.
  550                Return Value:     (char) - TRUE if there is an error reading the directory
  551                                  information, FALSE otherwise.
  552             
  553                Inputs:           Data is read from the disk drive.
  554                Outputs:          None.
  555             
  556                Error Handling:   If there is an error reading the directory, the saved
  557                                  information is set to reasonable values and TRUE is
  558                                  returned.
  559             
  560                Algorithms:       None.
  561                Data Structures:  None.
  562             
  563                Shared Variables: dir_sector   - filled with a sector of directory entries.
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE  11


  564                                  dir_offset   - set to zero (0), 1st sector of directory.
  565                                  start_sector - set to the passed sector number.
  566                                  dirname      - set to the old value of filename.
  567                                  filename     - set to the filename of the current entry.
  568                                  cur_dir      - set to the current file entry.
  569                                  cur_sector   - set to the starting sector of the entry.
  570             
  571                Author:           Glen George
  572                Last Modified:    June 1, 2003
  573             
  574             */
  575             
  576             char  get_first_dir_entry(unsigned long int first_sector)
  577             {
  578     1           /* variables */
  579     1           char  error = FALSE;        /* read error flag */
  580     1       
  581     1       
  582     1       
  583     1           /* first save the current directory information */
  584     1           new_directory();
  585     1       
  586     1           /* now entering a directory, so save it as the directory name */
  587     1           strcpy(dirname, filename);
  588     1       
  589     1           /* and set the starting sector for the directory */
  590     1           start_sector = first_sector;
  591     1       
  592     1       
  593     1           /* setup the file variables for the get_next_dir_entry function */
  594     1           /* have to point at entry "before" first entry */
  595     1           cur_dir = ENTRIES_PER_SECTOR - 1;   /* think at end of previous sector */
  596     1           dir_offset = -1;                    /* will be updated to 0 */
  597     1       
  598     1       
  599     1           /* now can just use the get_next_dir_entry function to get first file */
  600     1           error = get_next_dir_entry();
  601     1       
  602     1       
  603     1           /* done, return with the error status */
  604     1           return  error;
  605     1       
  606     1       }
  607             
  608             
  609             
  610             
  611             /*
  612                get_next_dir_entry
  613             
  614                Description:      This function gets the next valid directory entry in
  615                                  the directory.  As necessary it reads sectors of 
  616                                  directory entries from the hard drive.  The long filename
  617                                  of the next directory entry is also read and the filename
  618                                  variable is set to this long filename if it exists or the
  619                                  8.3 filename if it does not exist.  The current sector
  620                                  number and directory entry number are also updated.  If
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE  12


  621                                  there is an error reading the directory entry the
  622                                  filename is set to the empty string, the starting sector
  623                                  number is set to 0, the directory information is properly
  624                                  initialized, and TRUE is returned.
  625             
  626                Arguments:        None.
  627                Return Value:     (char) - TRUE if there is an error reading the directory
  628                                  information, FALSE otherwise.
  629             
  630                Inputs:           Data is read from the disk drive.
  631                Outputs:          None.
  632             
  633                Error Handling:   If there is an error reading the directory, the saved
  634                                  information is set to reasonable values and TRUE is
  635                                  returned.
  636             
  637                Algorithms:       None.
  638                Data Structures:  None.
  639             
  640                Shared Variables: dir_sector          - accessed and possibly filled with a
  641                                                        sector of directory entries.
  642                                  dir_offset          - accessed and possibly updated to
  643                                                        the sector offset of the directory
  644                                                        entries.
  645                                  start_sector        - accessed to get the starting sector
  646                                                        of the current directory.
  647                                  sectors_per_cluster - accessed to compute starting sector
  648                                                        of an entry.
  649                                  first_file_sector   - accessed to compute starting sector
  650                                                        of an entry.
  651                                  filename            - set to the filename of the current
  652                                                        entry.
  653                                  cur_dir             - accessed and updated to the current
  654                                                        entry.
  655                                  cur_sector          - set to the starting sector of the
  656                                                        entry.
  657             
  658                Author:           Glen George
  659                Last Modified:    April 29, 2006
  660             
  661             */
  662             
  663             char  get_next_dir_entry()
  664             {
  665     1           /* variables */
  666     1           char  longfilename[MAX_LFN_LEN];    /* long filename of current entry */
  667     1           int   lfn_seq;                      /* sequence number for LFN */
  668     1           int   chksum;                       /* long filename checksum */
  669     1       
  670     1           int   old_dir_offset;               /* previous directory offset */
  671     1           int   old_cur_dir;                  /* old file entry in directory */
  672     1       
  673     1           char  error = FALSE;                /* read error flag */
  674     1           char  done = FALSE;                 /* done reading the directory info */
  675     1       
  676     1           int   i;                            /* general loop indices */
  677     1           int   k;
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE  13


  678     1       
  679     1       
  680     1       
  681     1           /* reset the filename to setup for this file */
  682     1           longfilename[0] = '\0';
  683     1       
  684     1           /* keep track of the old values (in case can't find a next entry */
  685     1           old_dir_offset = dir_offset;
  686     1           old_cur_dir = cur_dir;
  687     1       
  688     1       
  689     1           /* now find the next entry in this directory */
  690     1           while (!error && !done)  {
  691     2       
  692     2               /* check if need to read a new sector's worth of entries */
  693     2               if (cur_dir >= (ENTRIES_PER_SECTOR - 1))  {
  694     3       
  695     3                   /* need to read in a new sector of directory entries */
  696     3                   /* update the directory sector number */
  697     3                   dir_offset++;
  698     3                   /* read a sector of directory entries, watching for an error */
  699     3                   error = (get_blocks((start_sector + dir_offset + partition_start),
  700     3                                       1, (unsigned short int far *) dir_sector) != 1);
  701     3                   /* reset the pointer into the sector of entries */
  702     3                   /* set to -1 so will be properly incremented in a couple lines */
  703     3                   cur_dir = -1;
  704     3               }
  705     2       
  706     2       
  707     2               /* is this the first entry or the end of the directory */
  708     2               if ((cur_dir == -1) || (FILENAME(dir_sector[cur_dir], 0) != '\0'))
  709     2                   /* not end of the directory - update the entry number */
  710     2                   cur_dir++;
  711     2       
  712     2       
  713     2               /* try to find the next directory entry */
  714     2               while (!error && !done && (cur_dir < ENTRIES_PER_SECTOR))  {
  715     3       
  716     3                   /* check if this is a long filename or a normal entry */
  717     3                   if (ATTR(dir_sector[cur_dir]) == ATTRIB_LFN)  {
  718     4       
  719     4                       /* this is a long filename - collect characters */
  720     4                       /* assume ASCII instead of Unicode */
  721     4       
  722     4                       /* get the sequence number for this part of the filename */
  723     4                       /* make it zero-based */
  724     4                       lfn_seq = (L_SEQ_NUM(dir_sector[cur_dir]) & LFN_SEQ_MASK) - 1;
  725     4       
  726     4                       /* collect the pieces of the long filename */
  727     4                       for (k = 0; k < LFN_CHARS; k++)  {
  728     5                           /* figure out where the LFN characters are */
  729     5                           if (k < LFN1_CHARS)
  730     5                               longfilename[LFN_CHARS * lfn_seq + k] = L_LFN1(dir_sector[cur_dir], 2 * k);
  731     5                           else if (k < (LFN1_CHARS + LFN2_CHARS))
  732     5                               longfilename[LFN_CHARS * lfn_seq + k] = L_LFN2(dir_sector[cur_dir], 2 * (k - L
                -FN1_CHARS));
  733     5                           else
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE  14


  734     5                               longfilename[LFN_CHARS * lfn_seq + k] = L_LFN3(dir_sector[cur_dir], 2 * (k - L
                -FN1_CHARS - LFN2_CHARS));
  735     5                       }
  736     4       
  737     4                       /* check if this is the last entry */
  738     4                       if ((L_SEQ_NUM(dir_sector[cur_dir]) & LAST_LFN_ENTRY) != 0)  {
  739     5                           /* last entry so remember the checksum */
  740     5                           chksum = CHECKSUM(dir_sector[cur_dir]);
  741     5                           /* also terminate the filename */
  742     5                           longfilename[LFN_CHARS * (lfn_seq + 1)] = '\0';
  743     5                       }
  744     4                       
  745     4                       /* go to the next directory entry */
  746     4                       cur_dir++;
  747     4                   }
  748     3                   else  {
  749     4       
  750     4                       /* this is a normal entry */
  751     4                       /* first check if this entry really exists */
  752     4                       if (FILENAME(dir_sector[cur_dir], 0) == '\xE5')  {
  753     5       
  754     5                           /* deleted entry */
  755     5                           /* not a valid file, clear the long filename */
  756     5                           longfilename[0] = '\0';
  757     5                           /* and move to the next entry */
  758     5                           cur_dir++;
  759     5                       }
  760     4       
  761     4                       /* is it the end of directory marker */
  762     4                       else if (FILENAME(dir_sector[cur_dir], 0) == '\0')  {
  763     5       
  764     5                           /* end of directory marker */
  765     5                           /* not a valid file, clear the filename */
  766     5                           longfilename[0] = '\0';
  767     5                           /* need to restore the old file state (on last file) */
  768     5                           cur_dir = old_cur_dir;
  769     5                           /* check if need to restore the directory sector */
  770     5                           if (dir_offset != old_dir_offset)  {
  771     6                               /* need to restore the old directory sector */
  772     6                               error = (get_blocks((start_sector + old_dir_offset + partition_start),
  773     6                                                   1, (unsigned short int far *) dir_sector) != 1);
  774     6                               /* also restore the actual offset */
  775     6                               dir_offset = old_dir_offset;
  776     6                           }
  777     5                           /* restored state, now we're done */
  778     5                           done = TRUE;
  779     5                       }
  780     4       
  781     4                       /* is it . or .. */
  782     4                       else if (FILENAME(dir_sector[cur_dir], 0) == '.')  {
  783     5       
  784     5                           /* is it pointer to this directory or parent directory */
  785     5                           if (FILENAME(dir_sector[cur_dir], 1) == '.')  {
  786     6       
  787     6                               /* pointer to parent directory */
  788     6                               /* so get sector number and parent name */
  789     6                               cur_sector = get_dir_tos_sector();
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE  15


  790     6                               strcpy(filename, get_dir_tos_name());
  791     6                               /* and we are done */
  792     6                               done = TRUE;
  793     6                           }
  794     5                           else  {
  795     6       
  796     6                               /* pointer to current directory - skip it */
  797     6                               /* not a valid file, clear the long filename */
  798     6                               longfilename[0] = '\0';
  799     6                               /* and move to the next entry */
  800     6                               cur_dir++;
  801     6                           }
  802     5                       }
  803     4       
  804     4                       /* is it a volume label */
  805     4                       else if ((ATTR(dir_sector[cur_dir]) & ATTRIB_VOLUME) != 0)  {
  806     5       
  807     5                           /* it is a volume label, see if already have a directory name */
  808     5                           if (dirname[0] == '\0')  {
  809     6       
  810     6                               /* no directory name currently, use volume label */
  811     6                               /* now check if there is a long filename (shouldn't be) */
  812     6                               /* first compute the checksum for this entry */
  813     6                               /* if checksum OK and there is a filename - keep it */
  814     6                               if (longfilename[0] == '\0')  {
  815     7       
  816     7                                   /* no long filename, set the directory name from 8.3 name */
  817     7                                   /* copy the filename and extension (but no .) */
  818     7                                   /* start at first character of filename */
  819     7                                   k = 0;
  820     7                                   /* copy the full filename */
  821     7                                   for (i = 0; (i < DOS_FILENAME_LEN); i++)
  822     7                                       dirname[k++] = FILENAME(dir_sector[cur_dir], i);
  823     7       
  824     7                                   /* now append the extension */
  825     7                                   for (i = 0; (i < DOS_EXTENSION_LEN); i++)
  826     7                                       dirname[k++] = EXTENSION(dir_sector[cur_dir], i);
  827     7       
  828     7                                   /* finally, null terminate the string */
  829     7                                   dirname[k] = '\0';
  830     7                               }
  831     6                               else  {
  832     7       
  833     7                                   /* have a long filename - save it as the  directory name */
  834     7                                   strcpy(dirname, longfilename);
  835     7                               }
  836     6                           }
  837     5                           else  {
  838     6       
  839     6                               /* already have a directory name so ignore volume label */
  840     6                               /* means we cursored back up to the directory */
  841     6                               ;
  842     6                           }
  843     5       
  844     5                           /* in any case, erase any long file name */
  845     5                           longfilename[0] = '\0';
  846     5                           /* and move to the next entry (ignore volume label) */
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE  16


  847     5                           cur_dir++;
  848     5                       }
  849     4       
  850     4                       /* none of the above, so must actually be a file */
  851     4                       else  {
  852     5       
  853     5                           /* need to set the starting sector and filename */
  854     5                           cur_sector = (START_CLUSTER(dir_sector[cur_dir]) - 2) * sectors_per_cluster + firs
                -t_file_sector;
  855     5       
  856     5                           /* now check if there is a long filename */
  857     5                           /* first compute the checksum for this entry */
  858     5                           /* if checksum OK and there is a filename - keep it */
  859     5                           if (longfilename[0] == '\0')  {
  860     6       
  861     6                               /* no long filename, set the filename from 8.3 name */
  862     6                               /* copy the filename and extension */
  863     6                               /* start at first character of filename */
  864     6                               k = 0;
  865     6                               /* copy the filename without the trailing spaces */
  866     6                               for (i = 0; ((i < DOS_FILENAME_LEN) && (FILENAME(dir_sector[cur_dir], i) != ' 
                -')); i++)
  867     6                                   filename[k++] = FILENAME(dir_sector[cur_dir], i);
  868     6       
  869     6                               /* add the '.' separating name and extension */
  870     6                               filename[k++] = '.';
  871     6       
  872     6                               /* now add the extension, skipping trailing spaces */
  873     6                               for (i = 0; ((i < DOS_EXTENSION_LEN) && (EXTENSION(dir_sector[cur_dir], i) != 
                -' ')); i++)
  874     6                                   filename[k++] = EXTENSION(dir_sector[cur_dir], i);
  875     6       
  876     6                               /* finally, null terminate the string */
  877     6                               filename[k] = '\0';
  878     6                           }
  879     5                           else  {
  880     6       
  881     6                               /* have a long filename - save it as the filename */
  882     6                               strcpy(filename, longfilename);
  883     6                           }
  884     5       
  885     5                           /* got to the next entry so set the done flag */
  886     5                           done = TRUE;
  887     5                       }
  888     4                   }
  889     3               }
  890     2           }
  891     1       
  892     1       
  893     1           /* check if there was an error */
  894     1           if (error)  {
  895     2               /* had an error - clear out the data */
  896     2               /* clear the filename */
  897     2               filename[0] = '\0';
  898     2               /* set the sector to 0 */
  899     2               cur_sector = 0;
  900     2           }
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE  17


  901     1       
  902     1       
  903     1           /* finally done, return with the error status */
  904     1           return  error;
  905     1       
  906     1       }
  907             
  908             
  909             
  910             
  911             /*
  912                get_previous_dir_entry
  913             
  914                Description:      This function gets the previous valid directory entry in
  915                                  the directory.  As necessary it reads sectors of 
  916                                  directory entries from the hard drive.  The function
  917                                  backs up through the directory to the first standard
  918                                  directory entry prior the current one and then back
  919                                  before any long filename for that entry.  The long
  920                                  filename of the previous directory entry is also read and
  921                                  the filename variable is set to this long filename if it
  922                                  exists or the 8.3 filename if there is no long filename.
  923                                  The current sector number and directory entry number are
  924                                  also updated.  If there is an error reading the directory
  925                                  entry the filename is set to the empty string, the
  926                                  starting sector number is set to 0, the directory
  927                                  information is properly initialized, and TRUE is
  928                                  returned.
  929             
  930                Arguments:        None.
  931                Return Value:     (char) - TRUE if there is an error reading the directory
  932                                  information, FALSE otherwise.
  933             
  934                Inputs:           Data is read from the disk drive.
  935                Outputs:          None.
  936             
  937                Error Handling:   If there is an error reading the directory, the saved
  938                                  information is set to reasonable values and TRUE is
  939                                  returned.
  940             
  941                Algorithms:       None.
  942                Data Structures:  None.
  943             
  944                Shared Variables: dir_sector   - accessed and possibly filled with a sector
  945                                                 of directory entries.
  946                                  dir_offset   - accessed and possibly updated to the
  947                                                 sector offset of the directory entries.
  948                                  start_sector - accessed to get the starting sector of the
  949                                                 current directory.
  950                                  filename     - set to the filename of the current entry.
  951                                  cur_dir      - accessed and updated to the current entry.
  952                                  cur_sector   - set to the starting sector of the entry.
  953             
  954                Author:           Glen George
  955                Last Modified:    April 29, 2006
  956             
  957             */
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE  18


  958             
  959             char  get_previous_dir_entry()
  960             {
  961     1           /* variables */
  962     1           char  error = FALSE;        /* read error flag */
  963     1           char  done = FALSE;         /* done getting the previous directory info */
  964     1           char  have_entry = FALSE;   /* have the entry (but maybe not the filename) */
  965     1       
  966     1       
  967     1       
  968     1           /* find the previous entry in this directory */
  969     1           /* loop until find the entry or get an error */
  970     1           while (!error && !done)  {
  971     2       
  972     2               /* check if need to read a new sector's worth of entries */
  973     2               if (cur_dir == 0)  {
  974     3       
  975     3                   /* need to read in the previous sector of directory entries */
  976     3                   dir_offset--;
  977     3                   /* check if out of directory entries */
  978     3                   if (dir_offset < 0)  {
  979     4                       /* out of directory entries - reset to the start */
  980     4                       dir_offset = 0;
  981     4                       /* need to be sure "next" operation finds first entry */
  982     4                       cur_dir = -1;
  983     4                       /* and done */
  984     4                       done = TRUE;
  985     4                   }
  986     3                   else  {
  987     4                       /* have a directory entry to check, read the sector of */
  988     4                       /*    directory entries, watching for an error */
  989     4                       error = (get_blocks((start_sector + dir_offset + partition_start),
  990     4                                           1, (unsigned short int far *) dir_sector) != 1);
  991     4                       /* and reset to the last file entry in the directory */
  992     4                       cur_dir = ENTRIES_PER_SECTOR - 1;
  993     4                   }
  994     3               }
  995     2               else  {
  996     3       
  997     3                   /* still more files in this directory, just check the previous entry */
  998     3                   cur_dir--;
  999     3               }
 1000     2       
 1001     2       
 1002     2               /* if not an error or done, keep processing */
 1003     2               if (!done && !error)  {
 1004     3       
 1005     3                   /* if don't have the entry yet, check if this is it */
 1006     3                   if (!have_entry)  {
 1007     4       
 1008     4                       /* check if this is a file entry in the directory */
 1009     4                       have_entry = ((FILENAME(dir_sector[cur_dir], 0) != '\0')  &&
 1010     4                                     (FILENAME(dir_sector[cur_dir], 0) != '\xE5')  &&
 1011     4                                     (ATTR(dir_sector[cur_dir]) != ATTRIB_LFN));
 1012     4                   }
 1013     3                   else  {
 1014     4       
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE  19


 1015     4                       /* already have an entry, but need to skip its */
 1016     4                       /* potentional long filename too */
 1017     4                       if (ATTR(dir_sector[cur_dir]) != ATTRIB_LFN)  {
 1018     5                           /* not a long filename, must be done */
 1019     5                           done = TRUE;
 1020     5                       }
 1021     4                       else  {
 1022     5                           /* still part of a long filename for the entry */
 1023     5                           /* nothing to do, just keep going */
 1024     5                           ;
 1025     5                       }
 1026     4                   }
 1027     3               }
 1028     2           }
 1029     1       
 1030     1       
 1031     1           /* if finished without an error then get the actual previous filename */
 1032     1           if (done & !error)  {
 1033     2       
 1034     2               /* get the entry watching for errors */
 1035     2               /* since we've backed up past the previous entry, this will now */
 1036     2               /*    find the previous entry */
 1037     2               error = get_next_dir_entry();
 1038     2           }
 1039     1       
 1040     1       
 1041     1           /* check if there was an error */
 1042     1           if (error)  {
 1043     2               /* had an error - clear out the data */
 1044     2               /* clear the filename */
 1045     2               filename[0] = '\0';
 1046     2               /* set the sector to 0 */
 1047     2               cur_sector = 0;
 1048     2           }
 1049     1       
 1050     1       
 1051     1           /* finally done, return with the error status */
 1052     1           return  error;
 1053     1       
 1054     1       }
 1055             
 1056             
 1057             
 1058             
 1059             /* locally global variables for the stack routines */
 1060             
 1061             /* stack of directory information */
 1062             static  char               dirnames[MAX_PATH_CHARS];            /* names */
 1063             static  unsigned long int  dirsectorstack[MAX_NUM_SUBDIRS];     /* starting sectors */
 1064             static  int                dirnamestack[MAX_NUM_SUBDIRS];       /* name positions in dirnames */
 1065             static  int                dirstack_ptr;                        /* the stack pointer */
 1066             
 1067             
 1068             
 1069             
 1070             /*
 1071                init_dir_stack()
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE  20


 1072             
 1073                Description:      This function initializes the directory stack.  It clears
 1074                                  the directory names, zeros the first stack elements, and
 1075                                  initializes the stack pointer.
 1076             
 1077                Arguments:        None.
 1078                Return Value:     None.
 1079             
 1080                Input:            None.
 1081                Output:           None.
 1082             
 1083                Error Handling:   None.
 1084             
 1085                Algorithms:       None.
 1086                Data Structures:  None.
 1087             
 1088                Shared Variables: dirnames       - first character is set to '\0'.
 1089                                  dirsectorstack - first element is set to 0.
 1090                                  dirnamestack   - first element is set to 0.
 1091                                  dirstack_ptr   - initialized to -1.
 1092             
 1093                Author:           Glen George
 1094                Last Modified:    June 27, 2002
 1095             
 1096             */
 1097             
 1098             static  void  init_dir_stack()
 1099             {
 1100     1           /* variables */
 1101     1             /* none */
 1102     1       
 1103     1       
 1104     1       
 1105     1           /* set the string of names to the empty string */
 1106     1           dirnames[0] = '\0';
 1107     1       
 1108     1           /* initialize the first directory entries to 0 */
 1109     1           dirsectorstack[0] = 0;
 1110     1           dirnamestack[0] = 0;
 1111     1       
 1112     1           /* finally, set the stack pointer to empty stack */
 1113     1           dirstack_ptr = -1;
 1114     1       
 1115     1       
 1116     1           /* all done with the initialization - return */
 1117     1           return;
 1118     1       
 1119     1       }
 1120             
 1121             
 1122             
 1123             
 1124             /*
 1125                new_directory()
 1126             
 1127                Description:      This function handles a new directory.  It may be either
 1128                                  a subdirectory or a parent directory.  If a subdirectory
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE  21


 1129                                  the directory information (name and starting sector) is
 1130                                  added to the directory stack.  If a parent directory, it
 1131                                  is removed from the directory stack.  It is assumed that
 1132                                  the directory in question is the current entry.
 1133             
 1134                Arguments:        None.
 1135                Return Value:     None.
 1136             
 1137                Input:            None.
 1138                Output:           None.
 1139             
 1140                Error Handling:   None.
 1141             
 1142                Algorithms:       None.
 1143                Data Structures:  None.
 1144             
 1145                Shared Variables: dirnames       - update to add or remove directory names.
 1146                                  dirsectorstack - may be updated to add a directory
 1147                                                   starting sector location.
 1148                                  dirnamestack   - may be updated to add the starting
 1149                                                   character number in dirnames[] for this
 1150                                                   directory name.
 1151                                  dirstack_ptr   - updated to adjust the stack.
 1152                                  dirname        - accessed for the current directory name.
 1153                                  start_sector   - accessed for the directory starting
 1154                                                   sector number.
 1155             
 1156                Author:           Glen George
 1157                Last Modified:    June 1, 2003
 1158             
 1159             */
 1160             
 1161             static  void  new_directory()
 1162             {
 1163     1           /* variables */
 1164     1             /* none */
 1165     1       
 1166     1       
 1167     1       
 1168     1           /* check if the current entry matches the top of the stack */
 1169     1           if ((dirstack_ptr >= 0) && (dirsectorstack[dirstack_ptr] == cur_sector))  {
 1170     2       
 1171     2               /* new directory is on stack - need to pop it off of the stack */
 1172     2               /* first get rid of the name */
 1173     2               dirnames[dirnamestack[dirstack_ptr]] = '\0';
 1174     2               /* now just decrement the stack pointer */
 1175     2               dirstack_ptr--;
 1176     2           }
 1177     1           else  {
 1178     2       
 1179     2               /* does not match top of the stack, need to push new value */
 1180     2               /* note - push the info for the current directory, not entry */
 1181     2               /* make sure not out of space */
 1182     2               if ((dirstack_ptr < (MAX_NUM_SUBDIRS - 1)) &&
 1183     2                   ((strlen(dirnames) + strlen(dirname)) < MAX_PATH_CHARS))  {
 1184     3       
 1185     3                   /* there is room - update the stack pointer */
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE  22


 1186     3                   dirstack_ptr++;
 1187     3                   /* save the sector */
 1188     3                   dirsectorstack[dirstack_ptr] = start_sector;
 1189     3                   /* save the name pointer and the name */
 1190     3                   dirnamestack[dirstack_ptr] = strlen(dirnames);
 1191     3                   strcat(dirnames, dirname);
 1192     3               }
 1193     2               else  {
 1194     3       
 1195     3                   /* out of room in the stack - this shouldn't happen */
 1196     3                   ;
 1197     3               }
 1198     2           }
 1199     1       
 1200     1       
 1201     1           /* all done - return */
 1202     1           return;
 1203     1       
 1204     1       }
 1205             
 1206             
 1207             
 1208             
 1209             /*
 1210                get_dir_tos_name()
 1211             
 1212                Description:      This function returns the name of the directory on the
 1213                                  top of the directory stack.  If the stack is empty, the
 1214                                  empty string is returned.
 1215             
 1216                Arguments:        None.
 1217                Return Value:     (const char *) - pointer to the name of the directory on
 1218                                  the top of the directory stack or the pointer to an empty
 1219                                  string if there is nothing on the stack.
 1220             
 1221                Input:            None.
 1222                Output:           None.
 1223             
 1224                Error Handling:   If nothing is on the stack an empty string is returned.
 1225             
 1226                Algorithms:       None.
 1227                Data Structures:  None.
 1228             
 1229                Shared Variables: dirnames     - accessed to get the directory name.
 1230                                  dirnamestack - accessed to find position of name.
 1231                                  dirstack_ptr - accessed to find stack entry.
 1232             
 1233                Author:           Glen George
 1234                Last Modified:    June 27, 2002
 1235             
 1236             */
 1237             
 1238             static  const char  *get_dir_tos_name()
 1239             {
 1240     1           /* variables */
 1241     1           const char  *name;
 1242     1       
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE  23


 1243     1       
 1244     1       
 1245     1           /* check if there is something in the directory stack */
 1246     1           if (dirstack_ptr >= 0)  {
 1247     2       
 1248     2               /* there is something on the stack, get the pointer to the name */
 1249     2               name = &(dirnames[dirnamestack[dirstack_ptr]]);
 1250     2           }
 1251     1           else  {
 1252     2       
 1253     2               /* nothing on the stack */
 1254     2               /* make sure the directory names list is empty */
 1255     2               dirnames[0] = '\0';
 1256     2               /* and return a pointer to that empty string */
 1257     2               name = dirnames;
 1258     2           }
 1259     1       
 1260     1       
 1261     1           /* all done - return with the name pointer */
 1262     1           return  name;
 1263     1       
 1264     1       }
 1265             
 1266             
 1267             
 1268             
 1269             /*
 1270                get_dir_tos_sector()
 1271             
 1272                Description:      This function returns the starting sector of the
 1273                                  directory on the top of the directory stack.  If the
 1274                                  stack is empty, zero (0) is returned.
 1275             
 1276                Arguments:        None.
 1277                Return Value:     (unsigned long int) - the starting sector of the
 1278                                  directory on the top of the directory stack or zero (0)
 1279                                  if there is nothing on the stack.
 1280             
 1281                Input:            None.
 1282                Output:           None.
 1283             
 1284                Error Handling:   If nothing is on the stack, zero (0) is returned.
 1285             
 1286                Algorithms:       None.
 1287                Data Structures:  None.
 1288             
 1289                Shared Variables: dirsectorstack - accessed to get sector number.
 1290                                  dirstack_ptr   - accessed to get sector number.
 1291             
 1292                Author:           Glen George
 1293                Last Modified:    June 27, 2002
 1294             
 1295             */
 1296             
 1297             static  unsigned long int  get_dir_tos_sector()
 1298             {
 1299     1           /* variables */
iC-86  COMPILER   FATUTIL                                                                    06/18/:8 21:13:40  PAGE  24


 1300     1           unsigned long int  sect;
 1301     1       
 1302     1       
 1303     1       
 1304     1           /* check if there is something in the directory stack */
 1305     1           if (dirstack_ptr >= 0)  {
 1306     2       
 1307     2               /* there is something on the stack, return the sector */
 1308     2               sect = dirsectorstack[dirstack_ptr];
 1309     2           }
 1310     1           else  {
 1311     2       
 1312     2               /* nothing on the stack, return 0 */
 1313     2               sect = 0;
 1314     2           }
 1315     1       
 1316     1       
 1317     1           /* all done - return with the starting sector */
 1318     1           return  sect;
 1319     1       
 1320     1       }



MODULE INFORMATION:

     CODE AREA SIZE               = 09B1H   2481D
     CONSTANT AREA SIZE           = 0000H      0D
     DATA AREA SIZE               = 08CAH   2250D
     MAXIMUM STACK SIZE           = 0218H    536D

iC-86 COMPILATION COMPLETE.      0 WARNINGS,     0 ERRORS
