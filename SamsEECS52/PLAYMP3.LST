iC-86  COMPILER   PLAYMP3                                                                    06/09/:8 00:46:19  PAGE   1


DOS 5.0 (038-N) iC-86 COMPILER V4.0, COMPILATION OF MODULE PLAYMP3
OBJECT MODULE PLACED IN PLAYMP3.OBJ
COMPILER INVOKED BY: C:\ASMSTU~1\IC86.EXE PLAYMP3.C DEBUG EXTEND MOD186 SMALL OPTIMIZE(0) ROM

 line level  incl 

    1             /****************************************************************************/
    2             /*                                                                          */
    3             /*                                 PLAYMP3                                  */
    4             /*                              Play Functions                              */
    5             /*                           MP3 Jukebox Project                            */
    6             /*                                EE/CS  52                                 */
    7             /*                                                                          */
    8             /****************************************************************************/
    9             
   10             /*
   11                This file contains the key processing and update functions for the Play
   12                operations of the MP3 Jukebox Project.  These functions take care of
   13                processing an input key (from the keypad) and updates for the Play
   14                operation.  They are called by the main loop of the MP3 Jukebox.  The
   15                functions included are:
   16                   begin_Play         - start playing from fast forward or reverse (key
   17                                        processing function)
   18                   begin_RptPlay      - start repeatedly playing from fast forward or
   19                                        reverse (key processing function)
   20                   cont_RptPlay       - switch to repeat play from standard play (key
   21                                        processing function)
   22                   start_Play         - begin playing the current track (key processing
   23                                        function)
   24                   start_RptPlay      - begin repeatedly playing the current track (key
   25                                        processing function)
   26                   stop_Play          - stop when playing (key processing function)
   27                   update_Play        - update function for play and repeat play (update
   28                                        function)
   29             
   30                The local functions included are:
   31                   init_Play          - actually start playing a track
   32             
   33                The locally global variable definitions included are:
   34                   buffers        - buffers for playing
   35                   empty_buffer   - buffer used for audio I/O when have no data available
   36                   current_buffer - which buffer is currently being played
   37                   play_time      - current time of play operation
   38                   rpt_play       - flag indicating doing repeat play instead of play
   39             
   40             
   41                Revision History
   42                   6/5/00   Glen George       Initial revision (from 3/6/99 version of
   43                                              playrec.c for the Digital Audio Recorder
   44                                              Project).
   45                   6/7/00   Glen George       Fixed calls to get_track_position() in
   46                                              init_Play and update_Play to call
   47                                              get_track_block_position() instead and
   48                                              fixed the size of some variables.
   49                   6/7/00   Glen George       Call elapsed_time() in init_Play() to reset
   50                                              the play timing.
   51                   6/14/00  Glen George       "Fix" arithmetic in init_Play() so it
iC-86  COMPILER   PLAYMP3                                                                    06/09/:8 00:46:19  PAGE   2


   52                                              actually does long int calculations.
   53                   6/14/00  Glen George       Fix buffer wrapping error in update_Play().
   54                   6/14/00  Glen George       Updated type casts on buffers[].p in
   55                                              init_Play() and changed empty_buffer type to
   56                                              match that of buffers[].p.
   57                   6/2/02   Glen George       Removed calls to ffrev_halt() in begin_Play()
   58                                              and begin_RptPlay() since they are no longer
   59                                              needed and the function no longer exists.
   60                   6/2/02   Glen George       Output the absolute value of the time in
   61                                              update_Play() so tracks with unknown length
   62                                              will automatically count up in time.  Also
   63                                              requires that stdlib.h be included.
   64                   6/2/02   Glen George       Use MAKE_FARPTR macro instead of inline code
   65                                              to create far pointers.
   66                   6/2/02   Glen George       Use size_t instead of int for array indices.
   67                   6/2/02   Glen George       Updated comments.
   68                   6/10/02  Glen George       Added use of SECTOR_ADJUST constant for
   69                                              dealing with hard drives with different
   70                                              geometries.
   71                   6/5/03   Glen George       Updated start_Play and start_RptPlay to
   72                                              handle FAT directory structures by checking
   73                                              if the current track is a directory or a
   74                                              song (file).
   75                   6/5/03   Glen George       Added #include of fatutil.h for function
   76                                              declarations needed by above change.
   77                   6/5/03   Glen George       Updated function headers.
   78                   6/5/03   Glen George       Added support for the PC simulation version
   79                                          in init_Play, stop_Play, and update_Play
   80                              (allocate/deallocate memory instead of
   81                              assuming DRAM).
   82                   6/9/05   Glen George       Fixed a minor bug in update_Play that caused
   83                                              repeat play to "stutter" at the start of the
   84                                              track when repeating.
   85                   4/29/06  Glen George       Removed inclusion of stdlib.h - it's handled
   86                                              by mp3defs.h now.
   87                   4/29/06  Glen George       Changed buffers to be short ints instead of
   88                                              chars.
   89                   6/4/06   Glen George       Fixed allocated buffer size to match the fact
   90                                              that buffers are short ints, not chars.
   91                   6/6/06   Glen George       Made allocation buffer sizes more portable
   92                                              and fixed more byte/word problems.
   93                   6/6/06   Glen George       Unrolled part of a loop to fix a possible
   94                                              compiler issue with gcc.
   95                   6/6/06   Glen George       Added a temporary variable to fix a possible
   96                                          compiler issue with gcc.
   97                   6/6/06   Glen George       Updated comments.
   98             */
   99             
  100             
  101             
  102             /* library include files */
  103             #ifdef  PCVERSION
                  #endif
  106             
  107             /* local include files */
  108             #include  "mp3defs.h"
  109             #include  "keyproc.h"
iC-86  COMPILER   PLAYMP3                                                                    06/09/:8 00:46:19  PAGE   3


  110             #include  "updatfnc.h"
  111             #include  "trakutil.h"
  112             #include  "fatutil.h"
  113             
  114             
  115             
  116             
  117             /* local definitions */
  118               /* none */
  119             
  120             
  121             
  122             
  123             /* local function declarations */
  124             enum status  init_Play(enum status);            /* initialize playing */
  125             
  126             
  127             
  128             
  129             /* locally global variables */
  130             static struct audio_buf          buffers[NO_BUFFERS];/* buffers to play */
  131             static unsigned short int  far  *empty_buffer;       /* empty (no data) buffer */
  132             static int                       current_buffer;     /* buffer currently playing */
  133             
  134             static long int                  play_time;          /* time for play operation */
  135             static int                       rpt_play;           /* doing repeat play */
  136             
  137             
  138             
  139             
  140             /*
  141                start_Play
  142             
  143                Description:      This function handles the <Play> key when nothing is
  144                                  happening in the system.  If the current entry is a
  145                                  directory, that directory is entered.  If it is a song,
  146                                  it starts playing the track at the current position.  If
  147                                  there is no time remaining on the track (it is at the
  148                                  end) of if the current entry is a directory, the function
  149                                  returns with the passed status as the current state,
  150                                  otherwise it returns the play state as the current state.
  151             
  152                Arguments:        cur_status (enum status) - the current system status.
  153                Return Value:     (enum status) - the new system status: STAT_PLAY if there
  154                                  is something to play on the track, the passed status
  155                                  otherwise.
  156             
  157                Input:            None.
  158                Output:           None.
  159             
  160                Error Handling:   None.
  161             
  162                Algorithms:       None.
  163                Data Structures:  None.
  164             
  165                Shared Variables: rpt_play - set to FALSE.
  166             
iC-86  COMPILER   PLAYMP3                                                                    06/09/:8 00:46:19  PAGE   4


  167                Author:           Glen George
  168                Last Modified:    June 5, 2003
  169             
  170             */
  171             
  172             enum status  start_Play(enum status cur_status)
  173             {
  174     1           /* variables */
  175     1             /* none */
  176     1       
  177     1       
  178     1       
  179     1           /* check if we are on a directory or a song */
  180     1           if (cur_isDir())  {
  181     2       
  182     2               /* is a directory - move into it */
  183     2               if (!get_first_dir_entry(get_cur_file_sector()))
  184     2                   /* successfully got the new entry, load its data */
  185     2                   setup_cur_track_info();
  186     2               else
  187     2                   /* there was an error - load error track information */
  188     2                   setup_error_track_info();
  189     2       
  190     2               /* display the track information for this track */
  191     2               display_time(get_track_time());
  192     2               display_title(get_track_title());
  193     2               display_artist(get_track_artist());
  194     2           }
  195     1           else  {
  196     2       
  197     2               /* it's a song so set global flag to normal play (not repeat play) */
  198     2               rpt_play = FALSE;
  199     2       
  200     2               /* and start playing and update the status */
  201     2               cur_status = init_Play(cur_status);
  202     2           }
  203     1       
  204     1       
  205     1           /* return the new status */
  206     1           return  cur_status;
  207     1       
  208     1       }
  209             
  210             
  211             
  212             
  213             /*
  214                start_RptPlay
  215             
  216                Description:      This function handles the <Repeat Play> key when nothing
  217                                  is happening in the system.  If the current track is a
  218                                  song it starts playing the track at the current position.
  219                                  If there is no time remaining on the track (for example,
  220                                  it was fast forwarded) the track is started from the
  221                                  beginning.  If the track is empty or a directory, nothing
  222                                  is played and the function returns the passed status.
  223             
iC-86  COMPILER   PLAYMP3                                                                    06/09/:8 00:46:19  PAGE   5


  224                Arguments:        cur_status (enum status) - the current system status.
  225                Return Value:     (enum status) - the new status: STAT_PLAY if there is
  226                                  something on the track, the passed status otherwise.
  227             
  228                Input:            None.
  229                Output:           None.
  230             
  231                Error Handling:   None.
  232             
  233                Algorithms:       None.
  234                Data Structures:  None.
  235             
  236                Shared Variables: rpt_play - set to TRUE.
  237             
  238                Author:           Glen George
  239                Last Modified:    June 5, 2003
  240             
  241             */
  242             
  243             enum status  start_RptPlay(enum status cur_status)
  244             {
  245     1           /* variables */
  246     1             /* none */
  247     1       
  248     1       
  249     1       
  250     1           /* check if this is a directory or a song */
  251     1           if (!cur_isDir())  {
  252     2       
  253     2               /* not a directory, must be a song, so play it */
  254     2       
  255     2               /* set global flags to repeat play */
  256     2               rpt_play = TRUE;
  257     2       
  258     2               /* now start playing and get the status */
  259     2               cur_status = init_Play(cur_status);
  260     2           }
  261     1       
  262     1       
  263     1           /* return with the possibly new status */
  264     1           return  cur_status;
  265     1       
  266     1       }
  267             
  268             
  269             
  270             
  271             /*
  272                cont_RptPlay
  273             
  274                Description:      This function handles the <Repeat Play> key when already
  275                                  playing a track.  It just changes the locally global
  276                                  variable rpt_play (to TRUE indicating doing repeat play).
  277                                  The update function takes care of restarting the track at
  278                                  the end of the track.
  279             
  280                Arguments:        cur_status (enum status) - the current system status (not
iC-86  COMPILER   PLAYMP3                                                                    06/09/:8 00:46:19  PAGE   6


  281                                                             used).
  282                Return Value:     (enum status) - the new system status (STAT_PLAY).
  283             
  284                Input:            None.
  285                Output:           None.
  286             
  287                Error Handling:   None.
  288             
  289                Algorithms:       None.
  290                Data Structures:  None.
  291             
  292                Shared Variables: rpt_play - set to TRUE (doing repeat play).
  293             
  294                Author:           Glen George
  295                Last Modified:    Mar. 11, 1995
  296             
  297             */
  298             
  299             enum status  cont_RptPlay(enum status cur_status)
  300             {
  301     1           /* variables */
  302     1             /* none */
  303     1       
  304     1       
  305     1       
  306     1           /* now doing repeat play */
  307     1           rpt_play = TRUE;
  308     1       
  309     1       
  310     1           /* done setting up for repeat play - return the status (STAT_PLAY) */
  311     1           return  STAT_PLAY;
  312     1       
  313     1       }
  314             
  315             
  316             
  317             
  318             /*
  319                begin_Play
  320             
  321                Description:      This function handles the <Play> key when fast forwarding
  322                                  or reversing.  It turns off the fast forward or reverse
  323                                  operation and then starts playing the track at the
  324                                  current position.
  325             
  326                Arguments:        cur_status (enum status) - the current system status (not
  327                                                             used).
  328                Return Value:     (enum status) - the new system status (actually returned
  329                                  by start_Play, either STAT_IDLE if at the end of the
  330                                  track, or STAT_PLAY otherwise).
  331             
  332                Input:            None.
  333                Output:           None.
  334             
  335                Error Handling:   None.
  336             
  337                Algorithms:       None.
iC-86  COMPILER   PLAYMP3                                                                    06/09/:8 00:46:19  PAGE   7


  338                Data Structures:  None.
  339             
  340                Shared Variables: None.
  341             
  342                Author:           Glen George
  343                Last Modified:    June 2, 2002
  344             
  345             */
  346             
  347             enum status  begin_Play(enum status cur_status)
  348             {
  349     1           /* variables */
  350     1             /* none */
  351     1       
  352     1       
  353     1       
  354     1           /* start playing, returning the appropriate status */
  355     1           /* note: fast forward or reverse is turned off by change of state */
  356     1           /* note: want to return to idle state if at the end of the track */
  357     1           return  start_Play(STAT_IDLE);
  358     1       
  359     1       }
  360             
  361             
  362             
  363             
  364             /*
  365                begin_RptPlay
  366             
  367                Description:      This function handles the <Repeat Play> key when fast
  368                                  forwarding or reversing.  It turns off the fast forward
  369                                  or reverse operation and then starts playing the track at
  370                                  the current position (time).
  371             
  372                Arguments:        cur_status (enum status) - the current system status (not
  373                                                             used).
  374                Return Value:     (enum status) - the new status (actually returned by
  375                                  start_RptPlay, either STAT_IDLE if the track is empty, or
  376                                  STAT_PLAY otherwise).
  377             
  378                Input:            None.
  379                Output:           None.
  380             
  381                Error Handling:   None.
  382             
  383                Algorithms:       None.
  384                Data Structures:  None.
  385             
  386                Shared Variables: None.
  387             
  388                Author:           Glen George
  389                Last Modified:    June 2, 2002
  390             
  391             */
  392             
  393             enum status  begin_RptPlay(enum status cur_status)
  394             {
iC-86  COMPILER   PLAYMP3                                                                    06/09/:8 00:46:19  PAGE   8


  395     1           /* variables */
  396     1             /* none */
  397     1       
  398     1       
  399     1       
  400     1           /* now start repeat playing, returning the appropriate status */
  401     1           /* note: fast forward or reverse is turned off by change of state */
  402     1           /* note: want to return to idle state if nothing on the track */
  403     1           return  start_RptPlay(STAT_IDLE);
  404     1       
  405     1       }
  406             
  407             
  408             
  409             
  410             /*
  411                stop_Play
  412             
  413                Description:      This function handles the <Stop> key when playing.  It
  414                                  halts the audio system, resets the track to the start of
  415                                  the track, and changes the current status to idle.
  416             
  417                Arguments:        cur_status (enum status) - the current system status (not
  418                                                             used).
  419                Return Value:     (enum status) - the new status (STAT_IDLE).
  420             
  421                Input:            None.
  422                Output:           The new track time (the track length) is output.
  423             
  424                Error Handling:   None.
  425             
  426                Algorithms:       None.
  427                Data Structures:  None.
  428             
  429                Shared Variables: None.
  430             
  431                Author:           Glen George
  432                Last Modified:    June 5, 2003
  433             
  434             */
  435             
  436             enum status  stop_Play(enum status cur_status)
  437             {
  438     1           /* variables */
  439     1       #ifdef  PCVERSION
                  #else
  442     1           /* none */
  443     1       #endif
  444     1       
  445     1       
  446     1       
  447     1           /* first halt the audio output */
  448     1           audio_halt();
  449     1       
  450     1           /* if the PC version need to free memory */
  451     1       #ifdef PCVERSION
                  #endif
iC-86  COMPILER   PLAYMP3                                                                    06/09/:8 00:46:19  PAGE   9


  458     1       
  459     1           /* reset to the start of the current track */
  460     1           init_track();
  461     1       
  462     1           /* display the new track time */
  463     1           display_time(get_track_time());
  464     1       
  465     1       
  466     1           /* return with the new status */
  467     1           return  STAT_IDLE;
  468     1       
  469     1       }
  470             
  471             
  472             
  473             
  474             /*
  475                init_Play
  476             
  477                Description:      This function handles starting a track playing for the
  478                                  <Play> and <Repeat Play> keys.  It starts playing the
  479                                  track at the current position.  If there is no time
  480                                  remaining on the track (for example, it is at the end)
  481                                  the function returns with the current status, otherwise
  482                                  it returns with the status set to STAT_PLAY.
  483             
  484                Arguments:        cur_status (enum status) - the current system status.
  485                Return Value:     (enum status) - the new system status: STAT_PLAY if there
  486                                  is something to play on the track, the passed status
  487                                  otherwise.
  488             
  489                Input:            None.
  490                Output:           The new time for the track is output to the display.
  491             
  492                Error Handling:   None.
  493             
  494                Algorithms:       None.
  495                Data Structures:  None.
  496             
  497                Shared Variables: buffers        - initialized with data.
  498                                  empty_buffer   - filled with NO_MP3_DATA signal.
  499                                  current_buffer - set to first buffer (0).
  500                                  play_time      - set to the current track time.
  501                                  rpt_play       - used to determine normal or repeat play.
  502             
  503                Author:           Glen George
  504                Last Modified:    June 6, 2006
  505             
  506             */
  507             
  508             static  enum status  init_Play(enum status cur_status)
  509             {
  510     1           /* variables */
  511     1           int           blocks_to_read;       /* number of blocks to read */
  512     1           int           blocks_read;          /* blocks actually read from disk */
  513     1           int           tot_blocks_read = 0;  /* total number of blocks read */
  514     1       
iC-86  COMPILER   PLAYMP3                                                                    06/09/:8 00:46:19  PAGE  10


  515     1           long int      bytes_left;           /* bytes left in the track */
  516     1       
  517     1           int           have_buffer = FALSE;  /* have a buffer with data */
  518     1           int           end_track = FALSE;    /* at the end of the track */
  519     1       
  520     1           unsigned int  tmp;                  /* temporary variable for intermediate results */
  521     1                                               /*    (seems to fix a compiler bug) */
  522     1       
  523     1           int           i;                    /* loop index */
  524     1       
  525     1       
  526     1       
  527     1           /* first initialize the buffer pointers and buffer structure */
  528     1           for (i = 0; i < NO_BUFFERS; i++)  {
  529     2               /* nothing in the buffer, it isn't the end, and point to DRAM */
  530     2               buffers[i].size = 0;
  531     2               buffers[i].done = FALSE;
  532     2           }
  533     1       
  534     1           /* allocate the buffer (remember it is words (short ints) */
  535     1           /* unroll the loop to workaround a possible compiler problem */
  536     1       #ifdef  PCVERSION
                  #else
  542     1           buffers[0].p    = (unsigned short int far *) MAKE_FARPTR(DRAM_STARTSEG, 0UL);
  543     1           buffers[1].p    = (unsigned short int far *) MAKE_FARPTR(DRAM_STARTSEG, 1UL * BUFFER_SIZE * sizeof
                -(short int));
  544     1           buffers[2].p    = (unsigned short int far *) MAKE_FARPTR(DRAM_STARTSEG, 2UL * BUFFER_SIZE * sizeof
                -(short int));
  545     1       #endif
  546     1       
  547     1           /* need to setup empty buffer too */
  548     1           /* first the pointer */
  549     1       #ifdef  PCVERSION
                  #else
  553     1           empty_buffer = (unsigned short int far *) MAKE_FARPTR(DRAM_STARTSEG, (unsigned long int) NO_BUFFER
                -S * BUFFER_SIZE);
  554     1       #endif
  555     1           /* now fill it */
  556     1           for (i = 0; i < BUFFER_SIZE; i++)
  557     1               empty_buffer[i] = NO_MP3_DATA;
  558     1       
  559     1       
  560     1           /* now setup the playing time */
  561     1           play_time = get_track_time() * TIME_SCALE;
  562     1       
  563     1       
  564     1           /* now get the two buffers for the track from the disk */
  565     1           for (i = 0 ; (i < 2); i++)  {
  566     2       
  567     2               /* first check if at end of track */
  568     2               if (get_track_remaining_length() == 0)  {
  569     3                   /* at end of track - check if repeat playing */
  570     3                   if (rpt_play)  {
  571     4                       /* at end and repeat playing - restart at beginning */
  572     4                       init_track();
  573     4                       /* need to reset total number of blocks read for track too */
  574     4                       tot_blocks_read = 0;
iC-86  COMPILER   PLAYMP3                                                                    06/09/:8 00:46:19  PAGE  11


  575     4                   }
  576     3                   else  {
  577     4                       /* at end, but not repeating, so set flag */
  578     4                       end_track = TRUE;
  579     4                   }
  580     3               }
  581     2       
  582     2               /* if not at end, read the blocks for this buffer */
  583     2               if (!end_track)  {
  584     3       
  585     3                   /* compute the number of blocks to read (block size is in words) */
  586     3                   bytes_left = get_track_remaining_length() - (2 * IDE_BLOCK_SIZE * tot_blocks_read);
  587     3                   blocks_to_read = (bytes_left + (2 * IDE_BLOCK_SIZE - 1)) / (2 * IDE_BLOCK_SIZE);
  588     3                   /* but only read up to BUFFER_BLOCKS blocks */
  589     3                   if (blocks_to_read > BUFFER_BLOCKS)
  590     3                       blocks_to_read = BUFFER_BLOCKS;
  591     3       
  592     3                   /* now read the blocks */
  593     3                   blocks_read = get_blocks(get_track_block_position() + tot_blocks_read + SECTOR_ADJUST, blo
                -cks_to_read, buffers[i].p);
  594     3       
  595     3                   /* check if read anything */
  596     3                   if (blocks_read > 0)  {
  597     4                       /* did read something, store how much (in words, not bytes) */
  598     4                       if (bytes_left >= (2 * IDE_BLOCK_SIZE * blocks_read))
  599     4                           /* all of the blocks are data */
  600     4                           tmp = blocks_read * IDE_BLOCK_SIZE;
  601     4                       else
  602     4                           /* remember the buffer size is in words */
  603     4                           tmp = (bytes_left + 1) / 2;
  604     4                       /* now store the buffer size */
  605     4                       buffers[i].size = tmp;
  606     4                       /* also set the flag that we read data */
  607     4                       have_buffer = TRUE;
  608     4                   }
  609     3                   else  {
  610     4                       /* couldn't read anything, it is the end of the track */
  611     4                       end_track = TRUE;
  612     4                   }
  613     3       
  614     3                   /* update number of blocks read so far */
  615     3                   tot_blocks_read += blocks_read;
  616     3               }
  617     2       
  618     2               /* if at the end of the track need to play the empty buffer */
  619     2               if (end_track)  {
  620     3                   buffers[i].size = BUFFER_SIZE;
  621     3                   buffers[i].done = TRUE;
  622     3                   buffers[i].p = empty_buffer;
  623     3               }
  624     2           }
  625     1       
  626     1       
  627     1           /* got a buffer, start the audio output if there is anything to output */
  628     1           if (have_buffer)  {
  629     2               /* have audio data - play it */
  630     2               audio_play(buffers[0].p, buffers[0].size);
iC-86  COMPILER   PLAYMP3                                                                    06/09/:8 00:46:19  PAGE  12


  631     2               /* on the first buffer */
  632     2               current_buffer = 0;
  633     2               /* also update the time display */
  634     2               display_time(play_time / TIME_SCALE);
  635     2               /* and reset the elapsed time */
  636     2               elapsed_time();
  637     2           }
  638     1       
  639     1       
  640     1           /* finally, return with the proper status */
  641     1           if (have_buffer)
  642     1               /* have something to play - return with play status */
  643     1               return  STAT_PLAY;
  644     1           else
  645     1               /* empty track - return with status unchanged */
  646     1               return  cur_status;
  647     1       
  648     1       }
  649             
  650             
  651             
  652             
  653             /*
  654                update_Play
  655             
  656                Description:      This function handles updates when playing or repeat
  657                                  playing.  It first checks if it is time for an update (by
  658                                  calling the function update) and if so it gets the next
  659                                  buffer to output and updates the time as is appropriate.
  660                                  When it reaches the end of the track (when not in repeat
  661                                  play mode) it uses the empty_buffer, which was previously
  662                                  filled with NO_MP3_DATA signal, to fill out the track and
  663                                  make sure all of the "good" signal has made it all the
  664                                  way through the pipeline.
  665             
  666                Arguments:        cur_status (enum status) - the current system status.
  667                Return Value:     (enum status) - the new system status: STAT_IDLE if have
  668                                  finished with the track, the passed status otherwise.
  669             
  670                Input:            None.
  671                Output:           The new time for the track is output to the display.
  672             
  673                Error Handling:   None.
  674             
  675                Algorithms:       None.
  676                Data Structures:  None.
  677             
  678                Shared Variables: buffers        - used for track data and filled.
  679                                  empty_buffer   - output at the end of the track.
  680                                  current_buffer - set to the buffer now being played.
  681                                  play_time      - updated to the time the track has left
  682                                                   to play.
  683                                  rpt_play       - accessed to determine normal or repeat
  684                                                   play mode.
  685             
  686                Author:           Glen George
  687                Last Modified:    June 6, 2006
iC-86  COMPILER   PLAYMP3                                                                    06/09/:8 00:46:19  PAGE  13


  688             
  689             */
  690             
  691             enum status  update_Play(enum status cur_status)
  692             {
  693     1           /* variables */
  694     1           long int  old_play_time = play_time;    /* previous time value */
  695     1       
  696     1           int       next_buffer;                  /* next buffer to play */
  697     1           int       previous_buffer;              /* buffer that just finished */
  698     1           int       fill_buffer;                  /* next buffer to fill */
  699     1       
  700     1           long int  start_pos;                    /* starting position for read */
  701     1           int       blocks_to_read;               /* number of blocks to read */
  702     1           int       blocks_read;                  /* blocks actually read from disk */
  703     1       
  704     1           long int  bytes_left;                   /* bytes left in the track */
  705     1           long int  words_read;                   /* words read and waiting to play */
  706     1       
  707     1           int       end_play = FALSE;             /* done playing (out of data) */
  708     1       
  709     1       #ifdef  PCVERSION
                  #endif
  712     1       
  713     1       
  714     1       
  715     1           /* figure out the next buffer */
  716     1           next_buffer = current_buffer + 1;
  717     1           /* check if wrapping around the end of the buffers */
  718     1           if (next_buffer >= NO_BUFFERS)
  719     1               next_buffer -= NO_BUFFERS;
  720     1       
  721     1       
  722     1           /* check if it is time to do an update */
  723     1           if (update(buffers[next_buffer].p, buffers[next_buffer].size))  {
  724     2       
  725     2               /* system was ready for the buffer - need to do an update */
  726     2       
  727     2               /* update the track position */
  728     2               /* get the buffer that just finished */
  729     2               previous_buffer = current_buffer - 1;
  730     2               /* take care of wrapping around start of array */
  731     2               if (previous_buffer < 0)
  732     2                   previous_buffer += NO_BUFFERS;
  733     2               /* now update the position if not starting over on a repeat play */
  734     2               /* this is necessary because previous_buffer and/or current_buffer */
  735     2               /* could be from the last iteration of the repeat play */
  736     2               if (!(buffers[previous_buffer].done || buffers[current_buffer].done))
  737     2                   /* not finishing an iteration - update the position */
  738     2                   /* remember that buffer size is in words and track position is */
  739     2                   /* maintained in bytes */
  740     2                   update_track_position(2 * buffers[previous_buffer].size);
  741     2       
  742     2               /* check if at the end of the track (if now outputting done buffer */
  743     2               /* this guarantees last buffer with data has been output) */
  744     2               if (buffers[current_buffer].done && !rpt_play)  {
  745     3       
iC-86  COMPILER   PLAYMP3                                                                    06/09/:8 00:46:19  PAGE  14


  746     3                   /* done with this track - turn off audio output */
  747     3                   audio_halt();
  748     3       
  749     3                   /* if the PC version need to free memory */
  750     3       #ifdef  PCVERSION
                  #endif
  757     3       
  758     3                   /* reset to start of track */
  759     3                   init_track();
  760     3       
  761     3                   /* set status back to idle */
  762     3                   cur_status = STAT_IDLE;
  763     3               }
  764     2               else  {
  765     3       
  766     3                   /* not done playing */
  767     3       
  768     3                   /* get the next buffer to fill */
  769     3                   fill_buffer = current_buffer + 2;
  770     3                   /* watch out for wrapping */
  771     3                   if (fill_buffer >= NO_BUFFERS)
  772     3                       fill_buffer -= NO_BUFFERS;
  773     3       
  774     3                   /* attempt to get another buffer */
  775     3       
  776     3                   /* first figure out where the buffer is and how big it is */
  777     3                   /* the next buffer has to be part of the newest iteration */
  778     3                   words_read = buffers[next_buffer].size;
  779     3                   /* only include the current buffer if it wasn't the end of the previous iteration */
  780     3                   if (!(buffers[current_buffer].done))
  781     3                       words_read += buffers[current_buffer].size;
  782     3                   /* now compute the number of bytes left and starting position */
  783     3                   bytes_left = get_track_remaining_length() - (2 * words_read);
  784     3                   start_pos = get_track_block_position() + (words_read / IDE_BLOCK_SIZE);
  785     3       
  786     3                   /* check if out of data */
  787     3                   if (bytes_left <= 0)  {
  788     4                       /* nothing left to play, check if repeating */
  789     4                       if (rpt_play)  {
  790     5                           /* repeating, so can reinitialize the track */
  791     5                           init_track();
  792     5                           /* and recompute the number of bytes left */
  793     5                           bytes_left = get_track_remaining_length();
  794     5                           /* and the starting position */
  795     5                           start_pos = get_track_block_position();
  796     5                           /* the block just sent was last one of the iteration */
  797     5                           buffers[next_buffer].done = TRUE;
  798     5                       }
  799     4                       else  {
  800     5                           /* not repeating, we're done */
  801     5                           end_play = TRUE;
  802     5                       }
  803     4                   }
  804     3       
  805     3                   /* if still playing, can get the data */
  806     3                   if (!end_play)  {
  807     4       
iC-86  COMPILER   PLAYMP3                                                                    06/09/:8 00:46:19  PAGE  15


  808     4                       /* compute the number of blocks to read */
  809     4                       blocks_to_read = (bytes_left + (2 * IDE_BLOCK_SIZE - 1)) / (2 * IDE_BLOCK_SIZE);
  810     4                       /* but only read up to BUFFER_BLOCKS blocks */
  811     4                       if (blocks_to_read > BUFFER_BLOCKS)
  812     4                           blocks_to_read = BUFFER_BLOCKS;
  813     4       
  814     4                       /* now read the blocks */
  815     4                       blocks_read = get_blocks(start_pos + SECTOR_ADJUST, blocks_to_read, buffers[fill_buffe
                -r].p);
  816     4       
  817     4                       /* check if read anything */
  818     4                       if (blocks_read > 0)  {
  819     5                           /* did read something, store how much (words, not bytes) */
  820     5                           if (bytes_left >= (2 * IDE_BLOCK_SIZE * blocks_read))
  821     5                               /* all of the blocks are data */
  822     5                               buffers[fill_buffer].size = blocks_read * IDE_BLOCK_SIZE;
  823     5                           else
  824     5                               /* only play the real data */
  825     5                               /* remember that buffer sizes are in words, not bytes */
  826     5                               buffers[fill_buffer].size = (bytes_left + 1) / 2;
  827     5                           /* this block is not the last one */
  828     5                           buffers[fill_buffer].done = FALSE;
  829     5                       }
  830     4                       else  {
  831     5                           /* couldn't read anything, it is the end of the track */
  832     5                           end_play = TRUE;
  833     5                       }
  834     4                   }
  835     3       
  836     3                   /* if at the end of play, need to play the empty buffer */
  837     3                   if (end_play)  {
  838     4                       buffers[fill_buffer].p = empty_buffer;
  839     4                       buffers[fill_buffer].size = BUFFER_SIZE;
  840     4                       buffers[fill_buffer].done = TRUE;
  841     4                   }
  842     3       
  843     3       
  844     3                   /* finally, update the current buffer */
  845     3                   current_buffer = next_buffer;
  846     3               }
  847     2           }
  848     1       
  849     1       
  850     1           /* always update the displayed time */
  851     1       
  852     1           /* get the elapsed time */
  853     1           play_time -= elapsed_time();
  854     1           /* see if we need to update the display */
  855     1           if ((play_time / TIME_SCALE) != (old_play_time / TIME_SCALE))
  856     1               /* the time has changed - update the display */
  857     1               display_time(abs(play_time / TIME_SCALE));
  858     1       
  859     1       
  860     1           /* done with update, return possibly new status */
  861     1           return  cur_status;
  862     1       
  863     1       }
iC-86  COMPILER   PLAYMP3                                                                    06/09/:8 00:46:19  PAGE  16


MODULE INFORMATION:

     CODE AREA SIZE               = 0654H   1620D
     CONSTANT AREA SIZE           = 0000H      0D
     DATA AREA SIZE               = 0024H     36D
     MAXIMUM STACK SIZE           = 0030H     48D

iC-86 COMPILATION COMPLETE.      0 WARNINGS,     0 ERRORS
