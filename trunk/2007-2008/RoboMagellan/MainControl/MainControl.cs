//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.1433
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using Microsoft.Ccr.Core;
using Microsoft.Dss.Core;
using Microsoft.Dss.Core.Attributes;
using Microsoft.Dss.ServiceModel.Dssp;
using Microsoft.Dss.Core.DsspHttp;
using Microsoft.Dss.ServiceModel.DsspServiceBase;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Xml;
using W3C.Soap;
using robomagellan = RoboMagellan;
using gps = RoboMagellan.GenericGPS.Proxy;
using motor = RoboMagellan.MotorControl.Proxy;
using submgr = Microsoft.Dss.Services.SubscriptionManager;
using compass = RoboMagellan.GenericCompass.Proxy;
using cone = RoboMagellan.ConeDetect.Proxy;

namespace RoboMagellan
{
    
    public class ControlDataPort : PortSet<MainControlUpdateState, Exception>{ }
    
    /// <summary>
    /// Implementation class for MainControl
    /// </summary>
    [DisplayName("MainControl")]
    [Description("The MainControl Service")]
    [Contract(Contract.Identifier)]
    public class MainControlService : DsspServiceBase
    {
        private static double DISTANCE_THRESHOLD = 3;

        private static double ANGLE_THRESHOLD = 20;

        private static double CONE_ANGLE_THRESHOLD = 10;

        private static int SPEED = 100;
        private static int CONE_SEARCH_SPEED = 20;
        private bool compassHasData = false;

        private ControlDataPort CPort = new ControlDataPort();


        [Partner("Gps", Contract = gps.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UseExistingOrCreate)]
        private gps.GenericGPSOperations _gpsPort = new gps.GenericGPSOperations();
        private gps.GenericGPSOperations _gpsNotify = new gps.GenericGPSOperations();

        [Partner("Compass", Contract = compass.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UseExistingOrCreate)]
        private compass.GenericCompassOperations _compassPort = new compass.GenericCompassOperations();
        private compass.GenericCompassOperations _compassNotify = new compass.GenericCompassOperations();

        [Partner("Motor", Contract = motor.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UseExistingOrCreate)]
        private motor.GenericMotorOperations _motorPort = new motor.GenericMotorOperations();
        private motor.GenericMotorOperations _motorNotify = new motor.GenericMotorOperations();

        [Partner("Cone", Contract = cone.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.UseExistingOrCreate)]
        private cone.ConeDetectOperations _conePort = new cone.ConeDetectOperations();
        private cone.ConeDetectOperations _coneNotify = new cone.ConeDetectOperations();

        [Partner("SubMgr", Contract = submgr.Contract.Identifier, CreationPolicy = PartnerCreationPolicy.CreateAlways)]
        submgr.SubscriptionManagerPort _subMgrPort = new submgr.SubscriptionManagerPort();



        /// <summary>
        /// _state
        /// </summary>
        private MainControlState _state = new MainControlState();
        private MainControlUpdateState _update = new MainControlUpdateState();
        
        /// <summary>
        /// _main Port
        /// </summary>
        [ServicePort("/maincontrol", AllowMultipleInstances=false)]
        private MainControlOperations _mainPort = new MainControlOperations();
        
        /// <summary>
        /// Default Service Constructor
        /// </summary>
        public MainControlService(DsspServiceCreationPort creationPort) : 
                base(creationPort)
        {
            _state._state = MainControlStates.STATE_SCANNING;
            //_state._state = MainControlStates.STATE_STOPPED;
        }
        
        /// <summary>
        /// Service Start
        /// MODIFIES STATE!
        /// </summary>
        protected override void Start()
        {
			base.Start();
			// Add service specific initialization here.
            Console.WriteLine("MainControl initializing");
            DirectoryInsert();

            //Activate Handlers for GPS, Compass, and Cone Detection
            Activate<ITask>(
                Arbiter.Interleave(
                    new TeardownReceiverGroup(),
                    new ExclusiveReceiverGroup(
                       Arbiter.Receive<gps.UTMNotification>(true, _gpsNotify, NotifyUTMHandler),
                       Arbiter.Receive<compass.CompassNotification>(true, _compassNotify, NotifyCompassHandler),
                       Arbiter.Receive<cone.ConeNotification>(true, _coneNotify, NotifyConeHandler),
                       Arbiter.Receive<motor.BumperActivated>(true, _motorNotify, NotifyBumperHandler)),
                   new ConcurrentReceiverGroup()));
            PostUpdate();

            //Subscribe to Compass, GPS, and Cone Detection
            _compassPort.Subscribe(_compassNotify);
            Console.WriteLine("Main Control subscribed to compass");
            _gpsPort.Subscribe(_gpsNotify);
            Console.WriteLine("Main Control subscribed to GPS, standing by");
            _conePort.Subscribe(_coneNotify);
            Console.WriteLine("Main Control subscribed to Cone Detection, standing by");
            _motorPort.Subscribe(_motorNotify);
            Console.WriteLine("Main Control subscribed to Bumper detection, standing by");
        }
        public void NotifyBumperHandler(motor.BumperActivated b)
        {
            motor.Stop stop = new motor.Stop();
            _state._state = MainControlStates.STATE_STOPPING;
            Console.WriteLine("Bumper Activated");
            PostUpdate();
            Arbiter.Activate(this.TaskQueue, Arbiter.Receive<DefaultSubmitResponseType>(false, stop.ResponsePort,
                delegate(DefaultSubmitResponseType a)
                {
                    _state._state = MainControlStates.STATE_STANDBY;
                    Console.WriteLine("Received stop! Entering Standby Mode");
                    PostUpdate();
                }));
            _motorPort.Post(stop);
        }
        public void NotifyConeHandler(cone.ConeNotification c)
        {
            //Console.WriteLine("Got Cone Data");
            if (!compassHasData) return;
            cone.CamData data = c.Body;
            int angle_requested;
            switch(_state._state){
                case MainControlStates.STATE_SCANNING:
                    //Check to see if there is a cone in sight. If not, turn and check again.
                    if (data.Detected)
                    {
                        //Check if the cone is dead ahead, if not, turn to it, if so, drive towards it.
                        Console.WriteLine("Cone Detected");
                        if (Math.Abs(data.Angle) > CONE_ANGLE_THRESHOLD)
                        {
                            Console.WriteLine("Cone is not ahead of robot");
                            angle_requested = data.Angle + _state._angle;
                            angle_requested %= 360;
                            motor.TurnData td = new motor.TurnData();
                            td.heading = angle_requested;
                            motor.Turn t = new motor.Turn(td);
                            Console.WriteLine("Turning to : " + angle_requested);
                            Console.WriteLine("Compass Heading is: " + _state._angle);
                            _state._state = MainControlStates.STATE_CONE_TURN;
                            PostUpdate();
                            
                            cone.MovementStatus ms1 = new cone.MovementStatus();
                            ms1._status = true;
                            _conePort.Post(new cone.Moving(ms1));
                            
                            Arbiter.Activate(this.TaskQueue, Arbiter.Receive<DefaultSubmitResponseType>(false, t.ResponsePort,
                                delegate(DefaultSubmitResponseType s)
                                {
                                    Console.WriteLine("Received turn complete! Cone should be ahead now. Moving foward!");
                                    _state._state = MainControlStates.STATE_CONE_DRIVE;
                                    PostUpdate();
                                    motor.MotorSpeed ms = new motor.MotorSpeed();
                                    ms.Left = (sbyte)CONE_SEARCH_SPEED;
                                    ms.Right = (sbyte)CONE_SEARCH_SPEED;
                                    motor.SetSpeed setspeed = new motor.SetSpeed(ms);
                                    
                                    cone.MovementStatus ms2 = new cone.MovementStatus();
                                    ms2._status = false;
                                    _conePort.Post(new cone.Moving(ms2));
                                    
                                    _motorPort.Post(setspeed);
                                }));

                            _motorPort.Post(t);
                        }
                        //Drive towards the cone.
                        else
                        {
                            Console.WriteLine("Cone is ahead, moving forward");
                            _state._state = MainControlStates.STATE_CONE_DRIVE;
                            PostUpdate();
                            motor.MotorSpeed ms = new motor.MotorSpeed();
                            ms.Left = (sbyte)CONE_SEARCH_SPEED;
                            ms.Right = (sbyte)CONE_SEARCH_SPEED;
                            motor.SetSpeed setspeed = new motor.SetSpeed(ms);
                            _motorPort.Post(setspeed);

                        }

                    }
                    //There is no cone in sight so turn a bit and check again.
                    else
                    {
                        Console.WriteLine("Cannot Find Cone");
                        angle_requested = _state._angle + cone.ConeDetectState.MAX_ANGLE;
                        angle_requested %= 360;
                        motor.TurnData td = new motor.TurnData();
                        td.heading = angle_requested;
                        motor.Turn t = new motor.Turn(td);

                        _state._state = MainControlStates.STATE_CONE_TURN;
                        Console.WriteLine("TURNING TO : " + angle_requested);
                        Console.WriteLine("Compass Heading is: " + _state._angle);
                        PostUpdate();
                        
                        cone.MovementStatus ms3 = new cone.MovementStatus();
                        ms3._status = true;
                        _conePort.Post(new cone.Moving(ms3));

                        Arbiter.Activate(this.TaskQueue, Arbiter.Receive<DefaultSubmitResponseType>(false, t.ResponsePort,
                            delegate(DefaultSubmitResponseType s)
                            {
                                Console.WriteLine("Received turn complete!");
                                _state._state = MainControlStates.STATE_SCANNING;
                                cone.MovementStatus mst = new cone.MovementStatus();
                                mst._status = false;
                                _conePort.Post(new cone.Moving(mst));
                                PostUpdate();
                            }));

                        _motorPort.Post(t);
                        
                    }
                    break;
                case MainControlStates.STATE_CONE_TURN:
                    return;
                    break;
                case MainControlStates.STATE_CONE_DRIVE:
                    //Right now need to manually stop the robot.
                    if (!data.Detected) // If it can't see it anymore, start scanning again.
                    {
                        motor.Stop stop = new motor.Stop();
                        _state._state = MainControlStates.STATE_STOPPING;
                        PostUpdate();
                        Arbiter.Activate(this.TaskQueue, Arbiter.Receive<DefaultSubmitResponseType>(false, stop.ResponsePort,
                            delegate(DefaultSubmitResponseType a)
                            {
                                _state._state = MainControlStates.STATE_SCANNING;
                                Console.WriteLine("Received stop! Lost sight of Cone so scanning again.");
                                PostUpdate();
                            }));
                        _motorPort.Post(stop);
                    }
                    break;
            }

        }
        public void NotifyCompassHandler(compass.CompassNotification c)
        {
            //if (_state._state != MainControlStates.STATE_DRIVING) return;
            
            // if the compass bearings arent in the same reference as the gps generated bearings this wont work, should ask EEs about this

            double absoluteBearing = GetAbsoluteBearing(_state._location, _state._destination);
            double actualBearing = c.Body.angle;
            Console.WriteLine("Actual Bearing: " + actualBearing);
            //Console.WriteLine("Absolute Bearing: " + absoluteBearing);

            _state._angle = (int)c.Body.angle;
            _state._waypointAngle = (int)absoluteBearing;
            SaveState(_state);
            PostUpdate();
            compassHasData = true;
            if (_state._state != MainControlStates.STATE_DRIVING) return;

            if (Math.Abs(absoluteBearing - actualBearing) > ANGLE_THRESHOLD)
            {
                Console.WriteLine("Stopping because actual bearing (" + actualBearing + ") outside angle threshold (intended bearing is " + absoluteBearing + ")");
                _state._state = MainControlStates.STATE_STOPPING;
                PostUpdate();
                motor.Stop stop = new motor.Stop();
                Arbiter.Activate(this.TaskQueue, Arbiter.Receive<DefaultSubmitResponseType>(false, stop.ResponsePort,
                    delegate(DefaultSubmitResponseType a)
                    {
                        _state._state = MainControlStates.STATE_STOPPED;
                        PostUpdate();
                        Console.WriteLine("Received stop!");
                    }));

                _motorPort.Post(stop);
            }
        }

        // UPDATES STATE!
        // fix concurrency!
        public void NotifyUTMHandler(gps.UTMNotification n)
        {
            Console.WriteLine("Received GPS notification, current state: " + _state._state);
            _state._location = n.Body;
            PostUpdate();

            //Check if the cone state machine is controlling the robot.
            if (_state._state == MainControlStates.STATE_CONE_DRIVE 
                    || _state._state == MainControlStates.STATE_SCANNING 
                    || _state._state == MainControlStates.STATE_CONE_TURN
                    || _state._state == MainControlStates.STATE_CONE_STOPPING
                    || _state._state == MainControlStates.STATE_CONE_STOPPED)
                return;
                
            if (_state._destination.East == 0 && _state._destination.North == 0)
            {
                _state._state = MainControlStates.STATE_STANDBY;
                PostUpdate();
            }
            switch (_state._state)
            {
                case MainControlStates.STATE_STANDBY :
                    if (_state._destinations.Count > 0)
                    {
                        _state._destination = _state._destinations.Dequeue();
                        _state._state = MainControlStates.STATE_STOPPED;
                        PostUpdate();
                    }
                    break;
                case MainControlStates.STATE_STOPPING :
                    return;
                    break;
                case MainControlStates.STATE_STOPPED:
                    if (_state._destination.East == 0.0)
                    {
                        _state._state = MainControlStates.STATE_SCANNING;
                        break;
                    }
                    if (GetDistanceSquared(_state._destination, n.Body) < DISTANCE_THRESHOLD)
                    {
                        if (_state._destinations.Count > 0)
                        {
                            _state._destination = _state._destinations.Dequeue();
                            PostUpdate();
                        }
                        return;
                    }
                    else
                    {
                        double absoluteBearing = GetAbsoluteBearing(n.Body, _state._destination);
                        Console.WriteLine("Beginning turn to " + absoluteBearing + " from " + _state._angle);
                        Console.WriteLine("Current position is: " + n.Body.East + " e , " + n.Body.North + " n., destination is " + _state._destination.East + " e, " + _state._destination.North + " n!");
                        motor.TurnData td = new motor.TurnData();
                        td.heading = (int)absoluteBearing;
                        motor.Turn t = new motor.Turn(td);


                        _state._state = MainControlStates.STATE_TURNING;
                        PostUpdate();

                        Arbiter.Activate(this.TaskQueue, Arbiter.Receive<DefaultSubmitResponseType>(false, t.ResponsePort,
                            delegate(DefaultSubmitResponseType s)
                            {
                                Console.WriteLine("Received turn complete!");
                                _state._state = MainControlStates.STATE_DRIVING;
                                PostUpdate();
                                motor.MotorSpeed ms = new motor.MotorSpeed();
                                ms.Left = (sbyte)SPEED;
                                ms.Right = (sbyte)SPEED;
                                motor.SetSpeed setspeed = new motor.SetSpeed(ms);
                                _motorPort.Post(setspeed);
                            }));
//                            delegate(Exception ex) { _state._state = MainControlStates.STATE_ERROR; }));


                        _motorPort.Post(t);
                    }
                    break;
                case MainControlStates.STATE_TURNING:
                    return;
                    break;
                case MainControlStates.STATE_DRIVING:
                    //GET DISTANCE SQUARED?
                    if (GetDistance(_state._destination, n.Body) < DISTANCE_THRESHOLD)
                    {
                        motor.Stop stop = new motor.Stop();

                        Console.WriteLine("Stopping!");
                        _state._state = MainControlStates.STATE_STOPPING;
                        PostUpdate();
                        Arbiter.Activate(this.TaskQueue, Arbiter.Receive<DefaultSubmitResponseType>(false, stop.ResponsePort,
                            delegate(DefaultSubmitResponseType a) { 
                                _state._state = MainControlStates.STATE_STOPPED;
                                PostUpdate();
                                Console.WriteLine("Received stop!");
                                if (_state._destinations.Count > 0)
                                {
                                    _state._destination = _state._destinations.Dequeue();
                                    PostUpdate();
                                }
                                else
                                {
                                    /*
                                    gps.UTMData empty = new gps.UTMData();
                                    empty.East = 0.0;
                                    empty.North = 0.0;
                                    _state._destination = empty;
                                     */
                                    //Destination reached, start looking for the cone.
                                    _state._state = MainControlStates.STATE_SCANNING;
                                    PostUpdate();
                                }
                            }));
//                            delegate(Exception ex) { _state._state = STATE_ERROR; }));

                        _motorPort.Post(stop);

                    }
                    else
                    {
                        return;
                    }
                    break;
                case MainControlStates.STATE_ERROR:
                    return;
                    break;
            }
        }

        private void PostUpdate()
        {
            _update._state = _state._state;
            _update._location = _state._location;
            _update._destination = _state._destination;
            // double check that this is safe...
            _update._destinations = _state._destinations.ToArray();
            _update._angle = _state._angle;
            _update._waypointAngle = _state._waypointAngle;
            CPort.Post(_update);
            SendNotification(_subMgrPort, new StateNotification(_update)); 
        }

        public double GetDistance(gps.UTMData a, gps.UTMData b)
        {
            return Math.Sqrt(GetDistanceSquared(a, b));
        }

        public double GetDistanceSquared(gps.UTMData a, gps.UTMData b)
        {
            double de = b.East - a.East;
            double dn = b.North - a.North;
            return de * de + dn * dn;
        }
        public double GetAbsoluteBearing(gps.UTMData loc, gps.UTMData dest)
        {
            double dx = dest.East - loc.East;
            double dy = dest.North - loc.North;
            //dy = -1 * dy;
            if (dx < 0)     // in quadrant 2 or 3; angle needs to be btw 180 and 360 exclusive
            {
                return 270 + 180 * (Math.Atan(dy / -dx) / Math.PI); // 270 + neg num = quadrant 3, 270 + pos num = quadrant 2
            }
            else            // in quadrant 1 or 4; angle needs to be btw 0 and 180 inclusive
            {
                return 90 - 180 * (Math.Atan(dy / dx) / Math.PI);  // 90 - neg num = quadrant 4, 90 - pos num = quadrant 1
            }
            //return MakePositiveAngle(180 * ((Math.Atan(dy / dx) * ((dx < 0) ? -1 : 1) / Math.PI)) +90);
        }

        /*
        public double MakePositiveAngle(double angle)
        {
            while (angle < 0)
            {
                angle += 360;
            }
            return angle;
        }
        */
        /// <summary>
        /// Get Handler
        /// </summary>
        /// <param name="get"></param>
        /// <returns></returns>
        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public virtual IEnumerator<ITask> GetHandler(Get get)
        {
            get.ResponsePort.Post(_state);
            yield break;
        }

        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public virtual IEnumerator<ITask> HttpGetHandler(HttpGet httpGet)
        {
            httpGet.ResponsePort.Post(new HttpResponseType(_update));
            yield break;
        }

        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public IEnumerator<ITask> HttpPostHandler(HttpPost httpPost)
        {
            yield break;
        }

        [ServiceHandler(ServiceHandlerBehavior.Concurrent)]
        public virtual IEnumerator<ITask> SubscribeHandler(Subscribe subscribe)
        {
            SubscribeRequestType request = subscribe.Body;
            Console.WriteLine("Control received subscribe request");
            yield return Arbiter.Choice(
                SubscribeHelper(_subMgrPort, request, subscribe.ResponsePort),
                delegate(SuccessResult success)
                {
                    Console.WriteLine("Subscription confirmed");
                    SendNotification<StateNotification>(_subMgrPort, request.Subscriber, _update);
                },
                delegate(Exception e)
                {
                    LogError(null, "Subscribe failed", e);
                }
            );

            yield break;
        }

        private void DataReceivedHandler(MainControlUpdateState d)
        {
            //Console.WriteLine("Received Control data");
            //_state.Coords = d;

            SendNotification(_subMgrPort, new StateNotification(d));
        }

        [ServiceHandler(ServiceHandlerBehavior.Exclusive)]
        public IEnumerator<ITask> EnqueueHandler(Enqueue s)
        {
            gps.UTMData data = s.Body;
            _state._destinations.Enqueue(data);
            PostUpdate();
            yield break;
        }

        [ServiceHandler(ServiceHandlerBehavior.Exclusive)]
        public IEnumerator<ITask> ResetHandler(Reset s)
        {
            _gpsPort = new RoboMagellan.GenericGPS.Proxy.GenericGPSOperations();
            _gpsNotify = new RoboMagellan.GenericGPS.Proxy.GenericGPSOperations();
            _compassPort = new RoboMagellan.GenericCompass.Proxy.GenericCompassOperations();
            _compassNotify = new compass.GenericCompassOperations();
            _motorPort = new motor.GenericMotorOperations();
            _conePort = new cone.ConeDetectOperations();
            _coneNotify = new cone.ConeDetectOperations();

            Console.WriteLine("MainControl re-initializing");
            DirectoryInsert();

            //Activate Handlers for GPS, Compass, and Cone Detection
            Activate<ITask>(
                Arbiter.Interleave(
                    new TeardownReceiverGroup(),
                    new ExclusiveReceiverGroup(
                       Arbiter.Receive<gps.UTMNotification>(true, _gpsNotify, NotifyUTMHandler),
                       Arbiter.Receive<compass.CompassNotification>(true, _compassNotify, NotifyCompassHandler),
                       Arbiter.Receive<cone.ConeNotification>(true, _coneNotify, NotifyConeHandler),
                       Arbiter.Receive<motor.BumperActivated>(true, _motorNotify, NotifyBumperHandler)),
                   new ConcurrentReceiverGroup()));
            PostUpdate();

            //Subscribe to Compass, GPS, and Cone Detection
            _compassPort.Subscribe(_compassNotify);
            Console.WriteLine("Main Control subscribed to compass");
            _gpsPort.Subscribe(_gpsNotify);
            Console.WriteLine("Main Control subscribed to GPS, standing by");
            _conePort.Subscribe(_coneNotify);
            Console.WriteLine("Main Control subscribed to Cone Detection, standing by");
            _motorPort.Subscribe(_motorNotify);
            Console.WriteLine("Main Control subscribed to Bumper detection, standing by");

            _state._state = MainControlStates.STATE_STANDBY;
            _state._destination = new RoboMagellan.GenericGPS.Proxy.UTMData();
            _state._angle = 0;
            _state._waypointAngle = 0;
            _state._location = new RoboMagellan.GenericGPS.Proxy.UTMData();
            _state._destinations.Clear();
            PostUpdate();
            yield break;
        }
    }
}
